<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>LeetCode 大全 - </title><meta name=author content="都将会"><meta name=author-link content><meta name=description content="常回来看看"><meta name=keywords content="LeetCode,practice,面试"><meta itemprop=name content="LeetCode 大全"><meta itemprop=description content="常回来看看"><meta itemprop=datePublished content="2022-06-08T08:08:08+08:00"><meta itemprop=dateModified content="2022-06-08T08:08:08+08:00"><meta itemprop=wordCount content="17756"><meta itemprop=image content="https://leni.fun/images/avatar.jpg"><meta itemprop=keywords content="LeetCode,DS,"><meta property="og:title" content="LeetCode 大全"><meta property="og:description" content="常回来看看"><meta property="og:type" content="article"><meta property="og:url" content="https://leni.fun/leetcode/"><meta property="og:image" content="https://leni.fun/images/avatar.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-08T08:08:08+08:00"><meta property="article:modified_time" content="2022-06-08T08:08:08+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://leni.fun/images/avatar.jpg"><meta name=twitter:title content="LeetCode 大全"><meta name=twitter:description content="常回来看看"><meta name=application-name content="都将会的 APP"><meta name=apple-mobile-web-app-title content="都将会的 APP"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://leni.fun/leetcode/><link rel=prev href=https://leni.fun/zookeeper_draft/><link rel=next href=https://leni.fun/rpc_draft/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"LeetCode 大全","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/leni.fun\/leetcode\/"},"genre":"posts","keywords":"LeetCode, DS","wordcount":17756,"url":"https:\/\/leni.fun\/leetcode\/","datePublished":"2022-06-08T08:08:08+08:00","dateModified":"2022-06-08T08:08:08+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"都将会"},"description":"常回来看看"}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"dark"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"dark"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/ title><img loading=lazy src=/images/icon.png srcset="/images/icon.png, /images/icon.png 1.5x, /images/icon.png 2x" sizes=auto data-title=/images/icon.png data-alt=/images/icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>都将会</span></a><span id=typeit-header-subtitle-desktop class="typeit header-subtitle"></span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 技术</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/life/><i class="fa-solid fa-camera-alt fa-fw fa-sm" aria-hidden=true></i> 生活</a></li><li class=menu-item><a class=menu-link href=/friends/><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=关键词搜索 id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title><img loading=lazy src=/images/icon.png srcset="/images/icon.png, /images/icon.png 1.5x, /images/icon.png 2x" sizes=auto data-title=/images/icon.png data-alt=/images/icon.png class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>都将会</span></a><span id=typeit-header-subtitle-mobile class="typeit header-subtitle"></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=关键词搜索 id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> 技术</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/life/><i class="fa-solid fa-camera-alt fa-fw fa-sm" aria-hidden=true></i> 生活</a></li><li class=menu-item><a class=menu-link href=/friends/><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-info-circle fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/ title>主页</a></li><li class=breadcrumb-item><a href=/posts/ title=Posts>Posts</a></li><li class="breadcrumb-item active" aria-current=page>LeetCode 大全</li></ol></nav><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>LeetCode 大全</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><img loading=lazy src=/images/avatar.jpg srcset="/images/avatar.jpg, /images/avatar.jpg 1.5x, /images/avatar.jpg 2x" sizes=auto data-title=都将会 data-alt=都将会 class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;都将会</span></span>
<span class=post-category>收录于 <a href=/categories/practice/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> practice</a></span></div><div class=post-meta-line><span title="发布于 2022-06-08 08:08:08"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2022-06-08>2022-06-08</time></span>&nbsp;<span title="更新于 2022-06-08 08:08:08"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2022-06-08>2022-06-08</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 17756 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 36 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="LeetCode 大全">
<i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#数组>数组</a><ul><li><a href=#560和为k的子数组java>[560]和为K的子数组.java</a><ul><li><a href=#思路>思路</a></li><li><a href=#代码>代码</a></li><li><a href=#复杂度>复杂度</a></li></ul></li><li><a href=#304二维区域和检索---矩阵不可变java>[304]二维区域和检索 - 矩阵不可变.java</a><ul><li><a href=#思路-1>思路</a></li><li><a href=#代码-1>代码</a></li><li><a href=#复杂度-1>复杂度</a></li></ul></li><li><a href=#1094拼车java>[1094]拼车.java</a><ul><li><a href=#思路-2>思路</a></li><li><a href=#代码-2>代码</a></li><li><a href=#复杂度-2>复杂度</a></li></ul></li><li><a href=#1109航班预订统计java>[1109]航班预订统计.java</a><ul><li><a href=#思路-3>思路</a></li><li><a href=#代码-3>代码</a></li><li><a href=#复杂度-3>复杂度</a></li></ul></li><li><a href=#二分搜索模板>二分搜索模板</a><ul><li><a href=#寻找左边界>寻找左边界</a></li><li><a href=#寻找右边界>寻找右边界</a></li></ul></li><li><a href=#875爱吃香蕉的珂珂java>[875]爱吃香蕉的珂珂.java</a><ul><li><a href=#思路-4>思路</a></li><li><a href=#代码-4>代码</a></li><li><a href=#复杂度-4>复杂度</a></li></ul></li><li><a href=#1011在-d-天内送达包裹的能力java>[1011]在 D 天内送达包裹的能力.java</a><ul><li><a href=#思路-5>思路</a></li><li><a href=#代码-5>代码</a></li><li><a href=#复杂度-5>复杂度</a></li></ul></li><li><a href=#下一个更大元素循环搜索>下一个更大元素（循环搜索）</a></li><li><a href=#搜索二维矩阵>搜索二维矩阵</a></li><li><a href=#折线图的最少线段数>折线图的最少线段数</a></li><li><a href=#三数之和>三数之和</a><ul><li><a href=#代码双指针>代码（双指针）</a></li><li><a href=#复杂度-6>复杂度</a></li></ul></li><li><a href=#颜色分类荷兰国旗问题>颜色分类（荷兰国旗问题）</a><ul><li><a href=#代码-6>代码</a></li><li><a href=#复杂度-7>复杂度</a></li></ul></li><li><a href=#31下一个排列java>[31]下一个排列.java</a></li><li><a href=#200岛屿数量java>[200]岛屿数量.java</a></li><li><a href=#695岛屿的最大面积java>[695]岛屿的最大面积.java</a></li><li><a href=#79单词搜索java>[79]单词搜索.java</a></li></ul></li><li><a href=#链表>链表</a><ul><li><a href=#21合并两个有序链表java>[21]合并两个有序链表.java</a></li><li><a href=#反转链表>反转链表</a><ul><li><a href=#代码-7>代码</a></li><li><a href=#复杂度-8>复杂度</a></li></ul></li><li><a href=#92反转链表-iijava>[92]反转链表 II.java</a></li><li><a href=#142环形链表-iijava>[142]环形链表 II.java</a><ul><li><a href=#思路-6>思路</a></li><li><a href=#代码-8>代码</a></li><li><a href=#复杂度-9>复杂度</a></li></ul></li><li><a href=#86分隔链表java>[86]分隔链表.java</a></li><li><a href=#148排序链表java>[148]排序链表.java</a></li><li><a href=#2两数相加java>[2]两数相加.java</a></li><li><a href=#143重排链表java>[143]重排链表.java</a></li></ul></li><li><a href=#二叉树>二叉树</a><ul><li><a href=#递归框架>递归框架</a></li><li><a href=#快速排序>快速排序</a></li><li><a href=#归并排序>归并排序</a></li><li><a href=#中序遍历二叉树>中序遍历二叉树</a></li><li><a href=#105从前序与中序遍历序列构造二叉树java>[105]从前序与中序遍历序列构造二叉树.java</a></li><li><a href=#114二叉树展开为链表java>[114]二叉树展开为链表.java</a><ul><li><a href=#思路-7>思路</a></li><li><a href=#代码-9>代码</a></li><li><a href=#复杂度-10>复杂度</a></li></ul></li><li><a href=#116填充每个节点的下一个右侧节点指针java>[116]填充每个节点的下一个右侧节点指针.java</a><ul><li><a href=#思路-8>思路</a></li><li><a href=#代码-10>代码</a></li><li><a href=#复杂度-11>复杂度</a></li></ul></li><li><a href=#701二叉搜索树中的插入操作java>[701]二叉搜索树中的插入操作.java</a><ul><li><a href=#思路-9>思路</a></li><li><a href=#代码-11>代码</a></li><li><a href=#复杂度-12>复杂度</a></li></ul></li><li><a href=#450删除二叉搜索树中的节点java>[450]删除二叉搜索树中的节点.java</a><ul><li><a href=#思路-10>思路</a></li><li><a href=#代码-12>代码</a></li><li><a href=#复杂度-13>复杂度</a></li></ul></li><li><a href=#102二叉树的层序遍历java>[102]二叉树的层序遍历.java</a><ul><li><a href=#思路-11>思路</a></li><li><a href=#代码-13>代码</a></li><li><a href=#复杂度-14>复杂度</a></li></ul></li><li><a href=#752打开转盘锁java>[752]打开转盘锁.java</a><ul><li><a href=#思路-12>思路</a></li><li><a href=#代码-14>代码</a></li><li><a href=#复杂度-15>复杂度</a></li></ul></li><li><a href=#662二叉树最大宽度java>[662]二叉树最大宽度.java</a></li><li><a href=#199二叉树的右视图java>[199]二叉树的右视图.java</a></li><li><a href=#236二叉树的最近公共祖先java>[236]二叉树的最近公共祖先.java</a></li><li><a href=#449-序列化和反序列化二叉搜索树java>[449] 序列化和反序列化二叉搜索树.java</a></li></ul></li><li><a href=#滑动窗口>滑动窗口</a><ul><li><a href=#模版>模版</a></li><li><a href=#3无重复字符的最长子串java>[3]无重复字符的最长子串.java</a><ul><li><a href=#思路-13>思路</a></li><li><a href=#代码-15>代码</a></li><li><a href=#复杂度-16>复杂度</a></li></ul></li><li><a href=#438找到字符串中所有字母异位词java>[438]找到字符串中所有字母异位词.java</a><ul><li><a href=#思路-14>思路</a></li><li><a href=#代码-16>代码</a></li><li><a href=#复杂度-17>复杂度</a></li></ul></li></ul></li><li><a href=#回溯>回溯</a><ul><li><a href=#46全排列java>[46]全排列.java</a><ul><li><a href=#思路-15>思路</a></li><li><a href=#代码-17>代码</a></li><li><a href=#复杂度-18>复杂度</a></li></ul></li><li><a href=#51n-皇后java>[51]N 皇后.java</a><ul><li><a href=#思路-16>思路</a></li><li><a href=#代码-18>代码</a></li><li><a href=#复杂度-19>复杂度</a></li></ul></li><li><a href=#22括号生成java>[22]括号生成.java</a><ul><li><a href=#思路-17>思路</a></li><li><a href=#代码-19>代码</a></li><li><a href=#复杂度-20>复杂度</a></li></ul></li><li><a href=#039-组合总和>039 组合总和</a><ul><li><a href=#代码-20>代码</a></li><li><a href=#复杂度-21>复杂度</a></li></ul></li><li><a href=#040-组合总和>040 组合总和Ⅱ</a><ul><li><a href=#代码-21>代码</a></li><li><a href=#复杂度-22>复杂度</a></li></ul></li><li><a href=#046-全排列>046 全排列</a><ul><li><a href=#代码-22>代码</a></li><li><a href=#复杂度-23>复杂度</a></li></ul></li><li><a href=#047-全排列>047 全排列Ⅱ</a><ul><li><a href=#代码-23>代码</a></li><li><a href=#复杂度-24>复杂度</a></li></ul></li></ul></li><li><a href=#动态规划>动态规划</a><ul><li><a href=#53最大子序和java>[53]最大子序和.java</a><ul><li><a href=#思路-18>思路</a></li><li><a href=#代码-24>代码</a></li><li><a href=#复杂度-25>复杂度</a></li></ul></li><li><a href=#300最长递增子序列java>[300]最长递增子序列.java</a><ul><li><a href=#思路-19>思路</a></li><li><a href=#代码-25>代码</a></li><li><a href=#复杂度-26>复杂度</a></li></ul></li></ul></li><li><a href=#栈和队列>栈和队列</a><ul><li><a href=#225用队列实现栈java>[225]用队列实现栈.java</a><ul><li><a href=#思路-20>思路</a></li><li><a href=#代码-26>代码</a></li></ul></li><li><a href=#232用栈实现队列java>[232]用栈实现队列.java</a><ul><li><a href=#思路-21>思路</a></li><li><a href=#代码-27>代码</a></li></ul></li><li><a href=#496下一个更大元素-ijava>[496]下一个更大元素 I.java</a><ul><li><a href=#思路-22>思路</a></li><li><a href=#代码-28>代码</a></li><li><a href=#复杂度-27>复杂度</a></li></ul></li><li><a href=#503下一个更大元素-iijava>[503]下一个更大元素 II.java</a><ul><li><a href=#思路-23>思路</a></li><li><a href=#代码-29>代码</a></li><li><a href=#复杂度-28>复杂度</a></li></ul></li><li><a href=#1047删除字符串中的所有相邻重复项java>[1047]删除字符串中的所有相邻重复项.java</a></li></ul></li><li><a href=#其他>其他</a><ul><li><a href=#并查集union-find算法990等式方程的可满足性java>并查集（Union-Find）算法：[990]等式方程的可满足性.java</a><ul><li><a href=#思路-24>思路</a></li><li><a href=#代码-30>代码</a></li><li><a href=#复杂度-29>复杂度</a></li></ul></li><li><a href=#050-powxn>050 Pow(x,n)</a><ul><li><a href=#int转换为long>int转换为long</a></li><li><a href=#代码迭代>代码（迭代）</a></li><li><a href=#复杂度-30>复杂度</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-pencil-alt fa-fw" aria-hidden=true></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2022-06-08，文中内容可能已过时。</div></div></div><h2 id=数组>数组</h2><h3 id=560和为k的子数组java>[560]和为K的子数组.java</h3><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><h4 id=思路>思路</h4><p>采用空间换时间策略，用 map 记录前序和。</p><h4 id=代码>代码</h4><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int subarraySum(int[] nums, int k) {
</span></span><span class=line><span class=cl>        int count = 0, sum = 0;
</span></span><span class=line><span class=cl>        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;() {{
</span></span><span class=line><span class=cl>            put(0, 1);
</span></span><span class=line><span class=cl>        }};
</span></span><span class=line><span class=cl>        for (int num : nums) {
</span></span><span class=line><span class=cl>            sum += num;
</span></span><span class=line><span class=cl>            count += map.getOrDefault(sum - k, 0);
</span></span><span class=line><span class=cl>            map.put(sum, map.getOrDefault(sum, 0) + 1);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return count;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=304二维区域和检索---矩阵不可变java>[304]二维区域和检索 - 矩阵不可变.java</h3><p>给定一个二维矩阵 matrix，以下类型的多个请求： 计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。 实现 NumMatrix 类： NumMatrix(int matrix) 给定整数矩阵 matrix 进行初始化 int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角(row2, col2) 的子矩阵的元素总和。</p><h4 id=思路-1>思路</h4><p><a class=lightgallery href=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png data-thumbnail=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png data-sub-html="<h2>https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png</h2>"><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h4 id=代码-1>代码</h4><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class NumMatrix {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // 存储左上角区域和
</span></span><span class=line><span class=cl>    private int[][] preSum;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public NumMatrix(int[][] matrix) {
</span></span><span class=line><span class=cl>        int m = matrix.length;
</span></span><span class=line><span class=cl>        int n = matrix[0].length;
</span></span><span class=line><span class=cl>        preSum = new int[m][n];
</span></span><span class=line><span class=cl>        preSum[0][0] = matrix[0][0];
</span></span><span class=line><span class=cl>        for (int i = 1; i &lt; m; i++) {
</span></span><span class=line><span class=cl>            preSum[i][0] = preSum[i - 1][0] + matrix[i][0];
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        for (int i = 1; i &lt; n; i++) {
</span></span><span class=line><span class=cl>            preSum[0][i] = preSum[0][i - 1] + matrix[0][i];
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        for (int i = 1; i &lt; m; i++) {
</span></span><span class=line><span class=cl>            for (int j = 1; j &lt; n; j++) {
</span></span><span class=line><span class=cl>                preSum[i][j] = matrix[i][j] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1];
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public int sumRegion(int row1, int col1, int row2, int col2) {
</span></span><span class=line><span class=cl>        int leftCol = (col1 == 0) ? 0 : preSum[row2][col1 - 1];
</span></span><span class=line><span class=cl>        int upRow = (row1 == 0) ? 0 : preSum[row1 - 1][col2];
</span></span><span class=line><span class=cl>        int leftUpArea = (row1 == 0 || col1 == 0) ? 0 : preSum[row1 - 1][col1 - 1];
</span></span><span class=line><span class=cl>        return preSum[row2][col2] - leftCol - upRow + leftUpArea;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-1>复杂度</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n^2)</li></ul><h3 id=1094拼车java>[1094]拼车.java</h3><p>假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。由于道路的限制，车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。
这儿有一份乘客行程计划表 trips，其中 trips[i] = [num_passengers, start_location, end_location] 包含了第 i 组乘客的行程信息：</p><ol><li>必须接送的乘客数量；</li><li>乘客的上车地点；</li><li>以及乘客的下车地点。</li></ol><p>这些给出的地点位置是从你的 初始 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。 请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false）。</p><h4 id=思路-2>思路</h4><p>利用差分数组，上车加乘客数，下车减乘客数，最后遍历一次检验是否有超载情况。</p><h4 id=代码-2>代码</h4><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public boolean carPooling(int[][] trips, int capacity) {
</span></span><span class=line><span class=cl>        // 差分数组
</span></span><span class=line><span class=cl>        int[] diff = new int[1001];
</span></span><span class=line><span class=cl>        // 统计每一站净上车人数
</span></span><span class=line><span class=cl>        for (int[] trip : trips) {
</span></span><span class=line><span class=cl>            int passengers = trip[0];
</span></span><span class=line><span class=cl>            int start = trip[1];
</span></span><span class=line><span class=cl>            int end = trip[2];
</span></span><span class=line><span class=cl>            diff[start] += passengers;
</span></span><span class=line><span class=cl>            diff[end] -= passengers;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        // 排查是否有超载情况
</span></span><span class=line><span class=cl>        int cur = 0;
</span></span><span class=line><span class=cl>        for (int i : diff) {
</span></span><span class=line><span class=cl>            cur += i;
</span></span><span class=line><span class=cl>            if (cur &gt; capacity) {
</span></span><span class=line><span class=cl>                return false;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return true;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-2>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=1109航班预订统计java>[1109]航班预订统计.java</h3><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。
有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。 请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。</p><h4 id=思路-3>思路</h4><p>利用差分数组，根据每一条数据，在 first 处加座位数，在 last +1 处减座位数，最后遍历累加得到 answer 数组。</p><h4 id=代码-3>代码</h4><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int[] corpFlightBookings(int[][] bookings, int n) {
</span></span><span class=line><span class=cl>        int[] diff = new int[n];
</span></span><span class=line><span class=cl>        int[] answer = new int[n];
</span></span><span class=line><span class=cl>        for (int[] booking : bookings) {
</span></span><span class=line><span class=cl>            int first = booking[0];
</span></span><span class=line><span class=cl>            int last = booking[1];
</span></span><span class=line><span class=cl>            int seats = booking[2];
</span></span><span class=line><span class=cl>            diff[first - 1] += seats;
</span></span><span class=line><span class=cl>            if (last &lt; n) {
</span></span><span class=line><span class=cl>                // 实际上是 last+1-1
</span></span><span class=line><span class=cl>                // +1 是因为座位在下一站才腾出来
</span></span><span class=line><span class=cl>                // -1 是因为航班从 1 开始编号，而数组从 0 开始编号
</span></span><span class=line><span class=cl>                diff[last] -= seats;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        answer[0] = diff[0];
</span></span><span class=line><span class=cl>        for (int i = 1; i &lt; n; i++) {
</span></span><span class=line><span class=cl>            answer[i] = answer[i - 1] + diff[i];
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return answer;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-3>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=二分搜索模板>二分搜索模板</h3><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int binary_search(int[] nums, int target) {
</span></span><span class=line><span class=cl>    int left = 0, right = nums.length - 1; 
</span></span><span class=line><span class=cl>    while(left &lt;= right) {
</span></span><span class=line><span class=cl>        int mid = left + (right - left) / 2;
</span></span><span class=line><span class=cl>        if (nums[mid] &lt; target) {
</span></span><span class=line><span class=cl>            left = mid + 1;
</span></span><span class=line><span class=cl>        } else if (nums[mid] &gt; target) {
</span></span><span class=line><span class=cl>            right = mid - 1; 
</span></span><span class=line><span class=cl>        } else if(nums[mid] == target) {
</span></span><span class=line><span class=cl>            // 直接返回
</span></span><span class=line><span class=cl>            return mid;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // 直接返回
</span></span><span class=line><span class=cl>    return -1;
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=寻找左边界>寻找左边界</h4><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int left_bound(int[] nums, int target) {
</span></span><span class=line><span class=cl>    int left = 0, right = nums.length - 1;
</span></span><span class=line><span class=cl>    while (left &lt;= right) {
</span></span><span class=line><span class=cl>        int mid = left + (right - left) / 2;
</span></span><span class=line><span class=cl>        if (nums[mid] &lt; target) {
</span></span><span class=line><span class=cl>            left = mid + 1;
</span></span><span class=line><span class=cl>        } else if (nums[mid] &gt; target) {
</span></span><span class=line><span class=cl>            right = mid - 1;
</span></span><span class=line><span class=cl>        } else if (nums[mid] == target) {
</span></span><span class=line><span class=cl>            // 别返回，锁定左侧边界
</span></span><span class=line><span class=cl>            right = mid - 1;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // 最后要检查 left 越界的情况
</span></span><span class=line><span class=cl>    if (left &gt;= nums.length || nums[left] != target)
</span></span><span class=line><span class=cl>        return -1;
</span></span><span class=line><span class=cl>    return left;
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=寻找右边界>寻找右边界</h4><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int right_bound(int[] nums, int target) {
</span></span><span class=line><span class=cl>    int left = 0, right = nums.length - 1;
</span></span><span class=line><span class=cl>    while (left &lt;= right) {
</span></span><span class=line><span class=cl>        int mid = left + (right - left) / 2;
</span></span><span class=line><span class=cl>        if (nums[mid] &lt; target) {
</span></span><span class=line><span class=cl>            left = mid + 1;
</span></span><span class=line><span class=cl>        } else if (nums[mid] &gt; target) {
</span></span><span class=line><span class=cl>            right = mid - 1;
</span></span><span class=line><span class=cl>        } else if (nums[mid] == target) {
</span></span><span class=line><span class=cl>            // 别返回，锁定右侧边界
</span></span><span class=line><span class=cl>            left = mid + 1;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    // 最后要检查 right 越界的情况
</span></span><span class=line><span class=cl>    if (right &lt; 0 || nums[right] != target)
</span></span><span class=line><span class=cl>        return -1;
</span></span><span class=line><span class=cl>    return right;
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=875爱吃香蕉的珂珂java>[875]爱吃香蕉的珂珂.java</h3><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。
珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。
珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><h4 id=思路-4>思路</h4><p><a class=lightgallery href=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png data-thumbnail=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png data-sub-html="<h2>https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png</h2>"><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><ol><li>以速度为自变量，花费时间为应变量，构造函数，定义域在 [1,10^9]</li><li>所求为最小速度，转换为寻找左边界</li><li>花费时间过长，应当加大速度，扩大 left 边界；花费时间相等或足够小，不直接返回，而是缩小 right 边界</li><li>退出循环前，<code>left==right && f(piles,mid)==h</code> ， 此时位于左边界，right = mid -1 后退出循环，因此最终返回 left</li></ol><h4 id=代码-4>代码</h4><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int minEatingSpeed(int[] piles, int h) {
</span></span><span class=line><span class=cl>        int left = 1, right = 1000000000;
</span></span><span class=line><span class=cl>        while (left &lt;= right) {
</span></span><span class=line><span class=cl>            int mid = left + (right - left) / 2;
</span></span><span class=line><span class=cl>            if (f(piles, mid) &gt; h) {
</span></span><span class=line><span class=cl>                left = mid + 1;
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                // 别返回，锁定左侧边界
</span></span><span class=line><span class=cl>                right = mid - 1;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return left;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private int f(int[] piles, int v) {
</span></span><span class=line><span class=cl>        int hours = 0;
</span></span><span class=line><span class=cl>        for (int pile : piles) {
</span></span><span class=line><span class=cl>            hours += pile / v;
</span></span><span class=line><span class=cl>            if (pile % v &gt; 0) {
</span></span><span class=line><span class=cl>                hours++;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return hours;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-4>复杂度</h4><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><h3 id=1011在-d-天内送达包裹的能力java>[1011]在 D 天内送达包裹的能力.java</h3><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。
传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p><h4 id=思路-5>思路</h4><ol><li>以承载量为自变量，花费天数为应变量，构造函数，承载量下限为最大的那个包裹的重量，上限为所有包裹加起来的重量。</li><li>所求为最小承载量，转换为寻找左边界</li><li>花费时间过长，应当加大承载量，扩大 left 边界；花费时间相等或足够小，不直接返回，而是缩小 right 边界</li><li>退出循环前，left==right && f(weights,mid)==days ， 此时位于左边界，right = mid -1 后退出循环，因此最终返回 left</li></ol><h4 id=代码-5>代码</h4><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int shipWithinDays(int[] weights, int days) {
</span></span><span class=line><span class=cl>        int left = 1, right = 1;
</span></span><span class=line><span class=cl>        for (int weight : weights) {
</span></span><span class=line><span class=cl>            if (weight &gt; left) {
</span></span><span class=line><span class=cl>                left = weight;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            right += weight;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        while (left &lt;= right) {
</span></span><span class=line><span class=cl>            int mid = left + (right - left) / 2;
</span></span><span class=line><span class=cl>            if (f(weights, mid) &gt; days) {
</span></span><span class=line><span class=cl>                left = mid + 1;
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                right = mid - 1;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return left;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private int f(int[] weights, int capacity) {
</span></span><span class=line><span class=cl>        int days = 1;
</span></span><span class=line><span class=cl>        int todayCapacity = capacity;
</span></span><span class=line><span class=cl>        for (int weight : weights) {
</span></span><span class=line><span class=cl>            if (weight &gt; todayCapacity) {
</span></span><span class=line><span class=cl>                // 今天不够装了，明天一来就装这个包裹
</span></span><span class=line><span class=cl>                days++;
</span></span><span class=line><span class=cl>                todayCapacity = capacity - weight;
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                // 今天装下这个包裹没问题
</span></span><span class=line><span class=cl>                todayCapacity -= weight;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return days;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-5>复杂度</h4><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><h3 id=下一个更大元素循环搜索>下一个更大元素（循环搜索）</h3><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int[] nextGreaterElements(int[] nums) {
</span></span><span class=line><span class=cl>        int[] res = new int[nums.length];
</span></span><span class=line><span class=cl>        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
</span></span><span class=line><span class=cl>        // 从后往前遍历
</span></span><span class=line><span class=cl>        for (int i = nums.length - 1; i &gt;= 0; i--) {
</span></span><span class=line><span class=cl>            while (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) {
</span></span><span class=line><span class=cl>                // 栈顶元素即将被 nums[i] 挡住
</span></span><span class=line><span class=cl>                stack.pop();
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            if (stack.isEmpty()) {
</span></span><span class=line><span class=cl>                res[i] = -1;
</span></span><span class=line><span class=cl>                // 后面找不到了，去前面找找看
</span></span><span class=line><span class=cl>                for (int j = 0; j &lt; i; j++) {
</span></span><span class=line><span class=cl>                    if (nums[j] &gt; nums[i]) {
</span></span><span class=line><span class=cl>                        res[i] = nums[j];
</span></span><span class=line><span class=cl>                        break;
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                res[i] = stack.peek();
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            stack.push(nums[i]);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=搜索二维矩阵>搜索二维矩阵</h3><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。</p><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public boolean searchMatrix(int[][] matrix, int target) {
</span></span><span class=line><span class=cl>       int m = matrix.length, n = matrix[0].length;
</span></span><span class=line><span class=cl>        int low = 0, high = m * n - 1;
</span></span><span class=line><span class=cl>        while (low &lt;= high) {
</span></span><span class=line><span class=cl>            int mid = (high - low) / 2 + low;
</span></span><span class=line><span class=cl>            int x = matrix[mid / n][mid % n];
</span></span><span class=line><span class=cl>            if (x &lt; target) {
</span></span><span class=line><span class=cl>                low = mid + 1;
</span></span><span class=line><span class=cl>            } else if (x &gt; target) {
</span></span><span class=line><span class=cl>                high = mid - 1;
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                return true;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return false;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=折线图的最少线段数>折线图的最少线段数</h3><p>给你一个二维整数数组 stockPrices ，其中 stockPrices[i] = [dayi, pricei] 表示股票在 dayi 的价格为 pricei 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p><p><a class=lightgallery href=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png data-thumbnail=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png data-sub-html="<h2>https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png</h2>"><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>请你返回要表示一个折线图所需要的 最少线段数 。</p><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int minimumLines(int[][] stockPrices) {
</span></span><span class=line><span class=cl>        if (stockPrices.length &lt;= 1) {
</span></span><span class=line><span class=cl>            return 0;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        Arrays.sort(stockPrices, (a, b) -&gt; {
</span></span><span class=line><span class=cl>            if (a[0] == b[0]) {
</span></span><span class=line><span class=cl>                return a[1] - b[1];
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                return a[0] - b[0];
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        });
</span></span><span class=line><span class=cl>        int count = 1;
</span></span><span class=line><span class=cl>        String k = getK(stockPrices[1][1] - stockPrices[0][1], stockPrices[1][0] - stockPrices[0][0]);
</span></span><span class=line><span class=cl>        for (int i = 2; i &lt; stockPrices.length; i++) {
</span></span><span class=line><span class=cl>            int dy = stockPrices[i][1] - stockPrices[i - 1][1];
</span></span><span class=line><span class=cl>            int dx = stockPrices[i][0] - stockPrices[i - 1][0];
</span></span><span class=line><span class=cl>            if (dy == 0 &amp;&amp; dx == 0) {
</span></span><span class=line><span class=cl>                continue;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            String tempK = getK(dy, dx);
</span></span><span class=line><span class=cl>            if (!k.equals(tempK)) {
</span></span><span class=line><span class=cl>                count++;
</span></span><span class=line><span class=cl>                k = tempK;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return count;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private String getK(int dy, int dx) {
</span></span><span class=line><span class=cl>        if (dx == 0) {
</span></span><span class=line><span class=cl>            return &#34;wx&#34;;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        //二者最大公约数，将两数化为最简，方便比较
</span></span><span class=line><span class=cl>        int gcd = gcd(Math.abs(dy), Math.abs(dx));
</span></span><span class=line><span class=cl>        dy /= gcd;
</span></span><span class=line><span class=cl>        dx /= gcd;
</span></span><span class=line><span class=cl>        return dy + &#34;/&#34; + dx;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * 求最大公约数
</span></span><span class=line><span class=cl>     *
</span></span><span class=line><span class=cl>     * @param a
</span></span><span class=line><span class=cl>     * @param b
</span></span><span class=line><span class=cl>     * @return
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    private int gcd(int a, int b) {
</span></span><span class=line><span class=cl>        if (b != 0) {
</span></span><span class=line><span class=cl>            return gcd(b, a % b);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return a;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=三数之和>三数之和</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><h4 id=代码双指针>代码（双指针）</h4><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
</span></span><span class=line><span class=cl>        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
</span></span><span class=line><span class=cl>        if (nums == null || nums.length &lt; 3) {
</span></span><span class=line><span class=cl>            return res;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        Arrays.sort(nums);
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; nums.length - 2; i++) {
</span></span><span class=line><span class=cl>            //减枝
</span></span><span class=line><span class=cl>            if (nums[i] &gt; 0) {
</span></span><span class=line><span class=cl>                break;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            //去重
</span></span><span class=line><span class=cl>            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
</span></span><span class=line><span class=cl>                continue;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            //后两数之和等于第一个数的相反数
</span></span><span class=line><span class=cl>            int target = -nums[i];
</span></span><span class=line><span class=cl>            int left = i + 1, right = nums.length - 1;
</span></span><span class=line><span class=cl>            while (left &lt; right) {
</span></span><span class=line><span class=cl>                if (nums[left] + nums[right] == target) {
</span></span><span class=line><span class=cl>                    res.add(Arrays.asList(nums[i], nums[left++], nums[right--]));
</span></span><span class=line><span class=cl>                    while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) {
</span></span><span class=line><span class=cl>                        left++;
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                    while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) {
</span></span><span class=line><span class=cl>                        right--;
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                } else if (nums[left] + nums[right] &lt; target) {
</span></span><span class=line><span class=cl>                    left++;
</span></span><span class=line><span class=cl>                } else {
</span></span><span class=line><span class=cl>                    right--;
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-6>复杂度</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：$$
\begin{cases} O(logn)，不允许改变参数\ O(1)，允许改变参数 \end{cases}
$$</li></ul><h3 id=颜色分类荷兰国旗问题>颜色分类（荷兰国旗问题）</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><h4 id=代码-6>代码</h4><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public void sortColors(int[] nums) {
</span></span><span class=line><span class=cl>        int left = 0, right = nums.length - 1;
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt;= right; i++) {
</span></span><span class=line><span class=cl>            if (nums[i] == 0) {
</span></span><span class=line><span class=cl>                //i把0给了left，left只可能把0给i
</span></span><span class=line><span class=cl>                swap(nums, left++, i);
</span></span><span class=line><span class=cl>            } else if (nums[i] == 2) {
</span></span><span class=line><span class=cl>                //i把2给了right，right可能把0或1给i，所以i不能立刻自增
</span></span><span class=line><span class=cl>                swap(nums, right--, i--);
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    private void swap(int[] nums, int index1, int index2) {
</span></span><span class=line><span class=cl>        int a = nums[index1];
</span></span><span class=line><span class=cl>        nums[index1] = nums[index2];
</span></span><span class=line><span class=cl>        nums[index2] = a;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-7>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=31下一个排列java>[31]下一个排列.java</h3><p>//整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 //// // 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 // //// 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 //// // 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 // 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 // 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 // //// 给你一个整数数组 nums ，找出 nums 的下一个排列。 //// 必须 原地 修改，只允许使用额外常数空间。</p><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public void nextPermutation(int[] nums) {
</span></span><span class=line><span class=cl>        int len = nums.length;
</span></span><span class=line><span class=cl>        int i = len - 2;
</span></span><span class=line><span class=cl>        // 从后往前找到第一个升序的数字
</span></span><span class=line><span class=cl>        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) {
</span></span><span class=line><span class=cl>            i--;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        // 如果找不到，则说明是最小的排列，需要重排
</span></span><span class=line><span class=cl>        if (i &gt;= 0) {
</span></span><span class=line><span class=cl>            int j = len - 1;
</span></span><span class=line><span class=cl>            // 从后往前找到第一个比i大的数字
</span></span><span class=line><span class=cl>            while (nums[i] &gt;= nums[j]) {
</span></span><span class=line><span class=cl>                j--;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            // 交换i和j
</span></span><span class=line><span class=cl>            swap(nums, i, j);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        // 反转后面的数字:从降序变成升序
</span></span><span class=line><span class=cl>        reverse(nums, i + 1);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public void swap(int[] nums, int i, int j) {
</span></span><span class=line><span class=cl>        int temp = nums[i];
</span></span><span class=line><span class=cl>        nums[i] = nums[j];
</span></span><span class=line><span class=cl>        nums[j] = temp;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public void reverse(int[] nums, int start) {
</span></span><span class=line><span class=cl>        int len = nums.length;
</span></span><span class=line><span class=cl>        int i = start, j = len - 1;
</span></span><span class=line><span class=cl>        while (i &lt; j) {
</span></span><span class=line><span class=cl>            swap(nums, i++, j--);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=200岛屿数量java>[200]岛屿数量.java</h3><p>给你一个由 &lsquo;1&rsquo;（陆地）和 &lsquo;0&rsquo;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。</p><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int numIslands(char[][] grid) {
</span></span><span class=line><span class=cl>        int count = 0;
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; grid.length; i++) {
</span></span><span class=line><span class=cl>            for (int j = 0; j &lt; grid[i].length; j++) {
</span></span><span class=line><span class=cl>                if (grid[i][j] == &#39;1&#39;) {
</span></span><span class=line><span class=cl>                    count++;
</span></span><span class=line><span class=cl>                    callBFS(grid, i, j);
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return count;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    private void callBFS(char[][] grid, int i, int j) {
</span></span><span class=line><span class=cl>        if (i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[i].length || grid[i][j] == &#39;0&#39;) {
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        grid[i][j] = &#39;0&#39;;
</span></span><span class=line><span class=cl>        callBFS(grid, i + 1, j);
</span></span><span class=line><span class=cl>        callBFS(grid, i - 1, j);
</span></span><span class=line><span class=cl>        callBFS(grid, i, j + 1);
</span></span><span class=line><span class=cl>        callBFS(grid, i, j - 1);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=695岛屿的最大面积java>[695]岛屿的最大面积.java</h3><p>//给你一个大小为 m x n 的二进制矩阵 grid 。 //// 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都//被 0（代表水）包围着。 //// 岛屿的面积是岛上值为 1 的单元格的数目。 //// 计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    boolean visited[][];
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public int maxAreaOfIsland(int[][] grid) {
</span></span><span class=line><span class=cl>        int res = 0;
</span></span><span class=line><span class=cl>        int rows = grid.length;
</span></span><span class=line><span class=cl>        int cols = grid[0].length;
</span></span><span class=line><span class=cl>        visited = new boolean[rows][cols];
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; rows; i++) {
</span></span><span class=line><span class=cl>            for (int j = 0; j &lt; cols; j++) {
</span></span><span class=line><span class=cl>                res = Math.max(res, area(i, j, grid));
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public int area(int row, int column, int[][] grid) {
</span></span><span class=line><span class=cl>        if (row &lt; 0 || row &gt;= grid.length || column &lt; 0 || column &gt;= grid[row].length || visited[row][column] || grid[row][column] == 0) {
</span></span><span class=line><span class=cl>            return 0;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        visited[row][column] = true;
</span></span><span class=line><span class=cl>        return 1 + area(row + 1, column, grid) + area(row - 1, column, grid) + area(row, column + 1, grid) + area(row, column - 1, grid);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=79单词搜索java>[79]单词搜索.java</h3><p>//给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 //// 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    boolean[][] visited;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public boolean exist(char[][] board, String word) {
</span></span><span class=line><span class=cl>        final int rows = board.length;
</span></span><span class=line><span class=cl>        final int cols = board[0].length;
</span></span><span class=line><span class=cl>        visited = new boolean[rows][cols];
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; rows; i++) {
</span></span><span class=line><span class=cl>            for (int j = 0; j &lt; cols; j++) {
</span></span><span class=line><span class=cl>                if (dfs(board, word, 0, i, j)) {
</span></span><span class=line><span class=cl>                    return true;
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return false;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private boolean dfs(char[][] board, String word, int index, int i, int j) {
</span></span><span class=line><span class=cl>        if (index == word.length()) {
</span></span><span class=line><span class=cl>            return true;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {
</span></span><span class=line><span class=cl>            return false;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        visited[i][j] = true;
</span></span><span class=line><span class=cl>        boolean res = dfs(board, word, index + 1, i + 1, j) ||
</span></span><span class=line><span class=cl>                dfs(board, word, index + 1, i - 1, j) ||
</span></span><span class=line><span class=cl>                dfs(board, word, index + 1, i, j + 1) ||
</span></span><span class=line><span class=cl>                dfs(board, word, index + 1, i, j - 1);
</span></span><span class=line><span class=cl>        visited[i][j] = false;
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h2 id=链表>链表</h2><h3 id=21合并两个有序链表java>[21]合并两个有序链表.java</h3><div class=highlight id=id-19><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    // 非递归
</span></span><span class=line><span class=cl>    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
</span></span><span class=line><span class=cl>        // 伪头结点
</span></span><span class=line><span class=cl>        ListNode dummyHead = new ListNode(-1);
</span></span><span class=line><span class=cl>        ListNode cur = dummyHead;
</span></span><span class=line><span class=cl>        while (l1 != null &amp;&amp; l2 != null) {
</span></span><span class=line><span class=cl>            if (l1.val &lt; l2.val) {
</span></span><span class=line><span class=cl>                cur.next = l1;
</span></span><span class=line><span class=cl>                l1 = l1.next;
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                cur.next = l2;
</span></span><span class=line><span class=cl>                l2 = l2.next;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            cur = cur.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        // 剩余部分
</span></span><span class=line><span class=cl>        cur.next = l1 == null ? l2 : l1;
</span></span><span class=line><span class=cl>        return dummyHead.next;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=反转链表>反转链表</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><h4 id=代码-7>代码</h4><div class=highlight id=id-20><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public ListNode reverseList(ListNode head) {
</span></span><span class=line><span class=cl>        ListNode pre = null, cur = head, next;
</span></span><span class=line><span class=cl>        while (cur != null) {
</span></span><span class=line><span class=cl>            next = cur.next;
</span></span><span class=line><span class=cl>            cur.next = pre;
</span></span><span class=line><span class=cl>            pre = cur;
</span></span><span class=line><span class=cl>            cur = next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        //cur==null 退出循环，pre此时指向之前的尾节点，现在的头节点。
</span></span><span class=line><span class=cl>        return pre;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-8>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=92反转链表-iijava>[92]反转链表 II.java</h3><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><a class=lightgallery href=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png data-thumbnail=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png data-sub-html="<h2>https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png</h2>"><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><div class=highlight id=id-21><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public ListNode reverseBetween(ListNode head, int left, int right) {
</span></span><span class=line><span class=cl>        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
</span></span><span class=line><span class=cl>        ListNode dummyNode = new ListNode(-1, head);
</span></span><span class=line><span class=cl>        ListNode pre = dummyNode;
</span></span><span class=line><span class=cl>        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
</span></span><span class=line><span class=cl>        // 建议写在 for 循环里，语义清晰
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; left - 1; i++) {
</span></span><span class=line><span class=cl>            pre = pre.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
</span></span><span class=line><span class=cl>        ListNode rightNode = pre;
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; right - left + 1; i++) {
</span></span><span class=line><span class=cl>            rightNode = rightNode.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 第 3 步：切断出一个子链表（截取链表）
</span></span><span class=line><span class=cl>        ListNode leftNode = pre.next;
</span></span><span class=line><span class=cl>        ListNode curr = rightNode.next;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 注意：切断链接
</span></span><span class=line><span class=cl>        pre.next = null;
</span></span><span class=line><span class=cl>        rightNode.next = null;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 第 4 步：同第 206 题，反转链表的子区间
</span></span><span class=line><span class=cl>        reverseLinkedList(leftNode);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 第 5 步：接回到原来的链表中
</span></span><span class=line><span class=cl>        pre.next = rightNode;
</span></span><span class=line><span class=cl>        leftNode.next = curr;
</span></span><span class=line><span class=cl>        return dummyNode.next;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private void reverseLinkedList(ListNode head) {
</span></span><span class=line><span class=cl>        // 也可以使用递归反转一个链表
</span></span><span class=line><span class=cl>        ListNode pre = null;
</span></span><span class=line><span class=cl>        ListNode cur = head;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        while (cur != null) {
</span></span><span class=line><span class=cl>            ListNode next = cur.next;
</span></span><span class=line><span class=cl>            cur.next = pre;
</span></span><span class=line><span class=cl>            pre = cur;
</span></span><span class=line><span class=cl>            cur = next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=142环形链表-iijava>[142]环形链表 II.java</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。</p><h4 id=思路-6>思路</h4><p><a class=lightgallery href=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png data-thumbnail=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png data-sub-html="<h2>https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png</h2>"><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>如图所示，先分析第一次相遇：
slow 走过距离：a+b
fast 走过距离：a+b+n(b+c)
又因为 fast 速度是 slow 的 2 倍，得：2(a+b) = a+b+n(b+c)
化简得：a=(n-1)(b+c)+c
这时，让 fast 指针回到起点，slow 指针留在原地，它们同时以相同速度运动 c 的距离，慢指针到达交点处，快指针距离交点距离是环长的整数倍，由于我们不知道 c 的大小，只能让快慢指针继续保持相同速度向前走，直到第二次相遇，相遇点必是交点。</p><h4 id=代码-8>代码</h4><div class=highlight id=id-22><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>public class Solution {
</span></span><span class=line><span class=cl>    public ListNode detectCycle(ListNode head) {
</span></span><span class=line><span class=cl>        ListNode slow = head, fast = head;
</span></span><span class=line><span class=cl>        while (fast != null &amp;&amp; fast.next != null) {
</span></span><span class=line><span class=cl>            slow = slow.next;
</span></span><span class=line><span class=cl>            fast = fast.next.next;
</span></span><span class=line><span class=cl>            if (slow == fast) {
</span></span><span class=line><span class=cl>                break;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        //无环
</span></span><span class=line><span class=cl>        if (fast == null || fast.next == null) {
</span></span><span class=line><span class=cl>            return null;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        fast = head;
</span></span><span class=line><span class=cl>        while (fast != slow) {
</span></span><span class=line><span class=cl>            slow = slow.next;
</span></span><span class=line><span class=cl>            fast = fast.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return fast;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-9>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=86分隔链表java>[86]分隔链表.java</h3><p>//给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 //// 你应当 保留 两个分区中每个节点的初始相对位置。 //// //// 示例 1： //// //输入：head = [1,4,3,2,5,2], x = 3//输出：[1,2,2,4,3,5]</p><div class=highlight id=id-23><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public ListNode partition(ListNode head, int x) {
</span></span><span class=line><span class=cl>        ListNode left = new ListNode(0);
</span></span><span class=line><span class=cl>        ListNode right = new ListNode(0);
</span></span><span class=line><span class=cl>        ListNode l = left;
</span></span><span class=line><span class=cl>        ListNode r = right;
</span></span><span class=line><span class=cl>        while (head != null) {
</span></span><span class=line><span class=cl>            if (head.val &lt; x) {
</span></span><span class=line><span class=cl>                l.next = head;
</span></span><span class=line><span class=cl>                l = l.next;
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                r.next = head;
</span></span><span class=line><span class=cl>                r = r.next;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            head = head.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        l.next = right.next;
</span></span><span class=line><span class=cl>        r.next = null;
</span></span><span class=line><span class=cl>        return left.next;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=148排序链表java>[148]排序链表.java</h3><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><div class=highlight id=id-24><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public ListNode sortList(ListNode head) {
</span></span><span class=line><span class=cl>        if (head == null || head.next == null) return head;
</span></span><span class=line><span class=cl>        ListNode slow = head, fast = head.next;
</span></span><span class=line><span class=cl>        while (fast != null &amp;&amp; fast.next != null) {
</span></span><span class=line><span class=cl>            slow = slow.next;
</span></span><span class=line><span class=cl>            fast = fast.next.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        ListNode right = sortList(slow.next);
</span></span><span class=line><span class=cl>        slow.next = null;
</span></span><span class=line><span class=cl>        ListNode left = sortList(head);
</span></span><span class=line><span class=cl>        return merge(left, right);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private ListNode merge(ListNode l1, ListNode l2) {
</span></span><span class=line><span class=cl>        ListNode dummy = new ListNode(0);
</span></span><span class=line><span class=cl>        ListNode cur = dummy;
</span></span><span class=line><span class=cl>        while (l1 != null &amp;&amp; l2 != null) {
</span></span><span class=line><span class=cl>            if (l1.val &lt; l2.val) {
</span></span><span class=line><span class=cl>                cur.next = l1;
</span></span><span class=line><span class=cl>                l1 = l1.next;
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                cur.next = l2;
</span></span><span class=line><span class=cl>                l2 = l2.next;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            cur = cur.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        cur.next = l1 == null ? l2 : l1;
</span></span><span class=line><span class=cl>        return dummy.next;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=2两数相加java>[2]两数相加.java</h3><p>//给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 //// 请你将两个数相加，并以相同形式返回一个表示和的链表。 //// 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 //// //// 示例 1： //// //输入：l1 = [2,4,3], l2 = [5,6,4]//输出：[7,0,8]//解释：342 + 465 = 807.</p><div class=highlight id=id-25><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
</span></span><span class=line><span class=cl>        ListNode dummyHead = new ListNode(0);
</span></span><span class=line><span class=cl>        ListNode cur = dummyHead;
</span></span><span class=line><span class=cl>        int carry = 0;
</span></span><span class=line><span class=cl>        while (l1 != null || l2 != null) {
</span></span><span class=line><span class=cl>            int x = l1 == null ? 0 : l1.val;
</span></span><span class=line><span class=cl>            int y = l2 == null ? 0 : l2.val;
</span></span><span class=line><span class=cl>            int sum = x + y + carry;
</span></span><span class=line><span class=cl>            carry = sum / 10;
</span></span><span class=line><span class=cl>            cur.next = new ListNode(sum % 10);
</span></span><span class=line><span class=cl>            cur = cur.next;
</span></span><span class=line><span class=cl>            if (l1 != null) l1 = l1.next;
</span></span><span class=line><span class=cl>            if (l2 != null) l2 = l2.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        if (carry &gt; 0) {
</span></span><span class=line><span class=cl>            cur.next = new ListNode(carry);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return dummyHead.next;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=143重排链表java>[143]重排链表.java</h3><p>//给定一个单链表 L 的头节点 head ，单链表 L 表示为： //// //L0 → L1 → … → Ln - 1 → Ln// //// 请将其重新排列后变为： //// //L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … //// 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><div class=highlight id=id-26><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public void reorderList(ListNode head) {
</span></span><span class=line><span class=cl>        if (head == null || head.next == null) {
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        ListNode l1 = head;
</span></span><span class=line><span class=cl>        ListNode slow = head, fast = head, prev = null;
</span></span><span class=line><span class=cl>        while (fast != null &amp;&amp; fast.next != null) {
</span></span><span class=line><span class=cl>            prev = slow;
</span></span><span class=line><span class=cl>            slow = slow.next;
</span></span><span class=line><span class=cl>            fast = fast.next.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        prev.next = null;
</span></span><span class=line><span class=cl>        ListNode l2 = slow;
</span></span><span class=line><span class=cl>        l2 = reverse(l2);
</span></span><span class=line><span class=cl>        l1 = merge(l1, l2);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private ListNode reverse(ListNode head) {
</span></span><span class=line><span class=cl>        ListNode prev = null;
</span></span><span class=line><span class=cl>        ListNode curNode = head;
</span></span><span class=line><span class=cl>        while (curNode != null) {
</span></span><span class=line><span class=cl>            ListNode nextNode = curNode.next;
</span></span><span class=line><span class=cl>            curNode.next = prev;
</span></span><span class=line><span class=cl>            prev = curNode;
</span></span><span class=line><span class=cl>            curNode = nextNode;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return prev;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private ListNode merge(ListNode l1, ListNode l2) {
</span></span><span class=line><span class=cl>        ListNode dummyHead = new ListNode(-1);
</span></span><span class=line><span class=cl>        ListNode curNode = dummyHead;
</span></span><span class=line><span class=cl>        while (l1 != null &amp;&amp; l2 != null) {
</span></span><span class=line><span class=cl>            curNode.next = l1;
</span></span><span class=line><span class=cl>            curNode = curNode.next;
</span></span><span class=line><span class=cl>            l1 = l1.next;
</span></span><span class=line><span class=cl>            curNode.next = l2;
</span></span><span class=line><span class=cl>            curNode = curNode.next;
</span></span><span class=line><span class=cl>            l2 = l2.next;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        curNode.next = l1 == null ? l2 : l1;
</span></span><span class=line><span class=cl>        return dummyHead.next;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h2 id=二叉树>二叉树</h2><p>快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历。</p><h3 id=递归框架>递归框架</h3><div class=highlight id=id-27><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* 二叉树遍历框架 */
</span></span><span class=line><span class=cl>void traverse(TreeNode root) {
</span></span><span class=line><span class=cl>    // 前序遍历
</span></span><span class=line><span class=cl>    traverse(root.left)
</span></span><span class=line><span class=cl>    // 中序遍历
</span></span><span class=line><span class=cl>    traverse(root.right)
</span></span><span class=line><span class=cl>    // 后序遍历
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=快速排序>快速排序</h3><div class=highlight id=id-28><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void sort(int[] nums, int lo, int hi) {
</span></span><span class=line><span class=cl>    /****** 前序遍历位置 ******/
</span></span><span class=line><span class=cl>    // 通过交换元素构建分界点 p
</span></span><span class=line><span class=cl>    int p = partition(nums, lo, hi);
</span></span><span class=line><span class=cl>    /************************/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    sort(nums, lo, p - 1);
</span></span><span class=line><span class=cl>    sort(nums, p + 1, hi);
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=归并排序>归并排序</h3><div class=highlight id=id-29><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void sort(int[] nums, int lo, int hi) {
</span></span><span class=line><span class=cl>    int mid = (lo + hi) / 2;
</span></span><span class=line><span class=cl>    sort(nums, lo, mid);
</span></span><span class=line><span class=cl>    sort(nums, mid + 1, hi);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /****** 后序遍历位置 ******/
</span></span><span class=line><span class=cl>    // 合并两个排好序的子数组
</span></span><span class=line><span class=cl>    merge(nums, lo, mid, hi);
</span></span><span class=line><span class=cl>    /************************/
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><p>可以说，只要涉及递归，都可以抽象成二叉树的问题。</p><h3 id=中序遍历二叉树>中序遍历二叉树</h3><div class=highlight id=id-30><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=nf>inorderTraversal</span><span class=p>(</span><span class=n>TreeNode</span><span class=w> </span><span class=n>root</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>res</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Deque</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span><span class=w> </span><span class=n>stack</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>TreeNode</span><span class=w> </span><span class=n>cur</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>root</span><span class=p>;</span><span class=w> </span><span class=n>cur</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>();</span><span class=w> </span><span class=n>cur</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cur</span><span class=p>.</span><span class=na>right</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 一直下到最左</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>cur</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>cur</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cur</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cur</span><span class=p>.</span><span class=na>left</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>cur</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span><span class=c1>// 每次出栈的就是中序遍历顺序的节点，然后在以下进行对应操作</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>res</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>cur</span><span class=p>.</span><span class=na>val</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 最后向右一步</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>res</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=105从前序与中序遍历序列构造二叉树java>[105]从前序与中序遍历序列构造二叉树.java</h3><div class=highlight id=id-31><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>TreeNode</span><span class=w> </span><span class=nf>buildTree</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>preorder</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>inorder</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>inorder</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>inorder</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>buildTreeHelper</span><span class=p>(</span><span class=n>preorder</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>preorder</span><span class=p>.</span><span class=na>length</span><span class=p>,</span><span class=w> </span><span class=n>inorder</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>inorder</span><span class=p>.</span><span class=na>length</span><span class=p>,</span><span class=w> </span><span class=n>map</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>* 指针左闭右开
</span></span></span><span class=line><span class=cl><span class=cm>*
</span></span></span><span class=line><span class=cl><span class=cm>* @param preorder
</span></span></span><span class=line><span class=cl><span class=cm>* @param p_start
</span></span></span><span class=line><span class=cl><span class=cm>* @param p_end
</span></span></span><span class=line><span class=cl><span class=cm>* @param inorder
</span></span></span><span class=line><span class=cl><span class=cm>* @param i_start
</span></span></span><span class=line><span class=cl><span class=cm>* @param i_end
</span></span></span><span class=line><span class=cl><span class=cm>* @param map
</span></span></span><span class=line><span class=cl><span class=cm>* @return
</span></span></span><span class=line><span class=cl><span class=cm>*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>TreeNode</span><span class=w> </span><span class=nf>buildTreeHelper</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>preorder</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>p_start</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>p_end</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>inorder</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>i_start</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>i_end</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                     </span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>map</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>p_start</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>p_end</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>root_val</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>preorder</span><span class=o>[</span><span class=n>p_start</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TreeNode</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>TreeNode</span><span class=p>(</span><span class=n>root_val</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>i_root_index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>root_val</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>leftNum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i_root_index</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>i_start</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// preorder 分为 [p_start + 1,p_start + leftNum + 1) 和 [p_start + leftNum + 1, p_end]，前序根结点在左边</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// inorder 分为 [i_start,i_root_index) 和 [i_root_index + 1,i_end)，少一个根结点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>root</span><span class=p>.</span><span class=na>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buildTreeHelper</span><span class=p>(</span><span class=n>preorder</span><span class=p>,</span><span class=w> </span><span class=n>p_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>p_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>leftNum</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>inorder</span><span class=p>,</span><span class=w> </span><span class=n>i_start</span><span class=p>,</span><span class=w> </span><span class=n>i_root_index</span><span class=p>,</span><span class=w> </span><span class=n>map</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>root</span><span class=p>.</span><span class=na>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buildTreeHelper</span><span class=p>(</span><span class=n>preorder</span><span class=p>,</span><span class=w> </span><span class=n>p_start</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>leftNum</span><span class=p>,</span><span class=w> </span><span class=n>p_end</span><span class=p>,</span><span class=w> </span><span class=n>inorder</span><span class=p>,</span><span class=w> </span><span class=n>i_root_index</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>i_end</span><span class=p>,</span><span class=w> </span><span class=n>map</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>root</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=114二叉树展开为链表java>[114]二叉树展开为链表.java</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><h4 id=思路-7>思路</h4><ol><li>把每个节点的左子树插入到该节点与右子树之间；</li><li>应用后序递归框架（左、右、根）。</li></ol><h4 id=代码-9>代码</h4><div class=highlight id=id-32><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public void flatten(TreeNode root) {
</span></span><span class=line><span class=cl>        // 1. 叶子节点
</span></span><span class=line><span class=cl>        if (root == null) return;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 2. 递归 flatten
</span></span><span class=line><span class=cl>        TreeNode left = root.left;
</span></span><span class=line><span class=cl>        TreeNode right = root.right;
</span></span><span class=line><span class=cl>        flatten(left);
</span></span><span class=line><span class=cl>        flatten(right);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 3. 拼左
</span></span><span class=line><span class=cl>        root.left = null;
</span></span><span class=line><span class=cl>        root.right = left;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 4. 拼右
</span></span><span class=line><span class=cl>        TreeNode p = root;
</span></span><span class=line><span class=cl>        while (p.right != null) {
</span></span><span class=line><span class=cl>            p = p.right;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        p.right = right;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-10>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=116填充每个节点的下一个右侧节点指针java>[116]填充每个节点的下一个右侧节点指针.java</h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。</p><h4 id=思路-8>思路</h4><ol><li>把每个节点的左子树指向右子树；</li><li>值得注意的是，左子树的右子树也要指向右子树的左子树；</li><li>应用前序递归框架（根、左、右）。</li></ol><h4 id=代码-10>代码</h4><div class=highlight id=id-33><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public Node connect(Node root) {
</span></span><span class=line><span class=cl>        if (root == null) {
</span></span><span class=line><span class=cl>            return null;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        connect(root.left, root.right);
</span></span><span class=line><span class=cl>        return root;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private void connect(Node left, Node right) {
</span></span><span class=line><span class=cl>        if (left == null || right == null) {
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        left.next = right;
</span></span><span class=line><span class=cl>        // 四个点，三个指向
</span></span><span class=line><span class=cl>        connect(left.left, left.right);
</span></span><span class=line><span class=cl>        connect(left.right, right.left);
</span></span><span class=line><span class=cl>        connect(right.left, right.right);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-11>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=701二叉搜索树中的插入操作java>[701]二叉搜索树中的插入操作.java</h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同</p><h4 id=思路-9>思路</h4><p>这题的关键在于重置 <strong>搜索路径</strong> 上节点的左或右子树，如果不为空，则递归；如果为空，直接 new 一个新节点，这个节点不需要做任何处理，它是会被上一次递归所指向的。</p><h4 id=代码-11>代码</h4><div class=highlight id=id-34><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public TreeNode insertIntoBST(TreeNode root, int val) {
</span></span><span class=line><span class=cl>        if (root == null) {
</span></span><span class=line><span class=cl>            return new TreeNode(val);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        if (val &gt; root.val) {
</span></span><span class=line><span class=cl>            root.right = insertIntoBST(root.right, val);
</span></span><span class=line><span class=cl>        } else {
</span></span><span class=line><span class=cl>            root.left = insertIntoBST(root.left, val);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return root;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-12>复杂度</h4><ul><li>时间复杂度：平均情况 O(logn)，最坏情况 O(n)</li><li>空间复杂度：平均情况 O(logn)，最坏情况 O(n)</li></ul><h3 id=450删除二叉搜索树中的节点java>[450]删除二叉搜索树中的节点.java</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><h4 id=思路-10>思路</h4><ol><li>首先，查找和删除这两步不能分开，因为删除还需要用到删除节点的上一个节点。</li><li>找到元素后，如果删除节点左右子树有空着的，只需要把另一棵子树移到当前位置即可，直接返回，这个节点不需要做任何处理，它是会被上一次递归所指向的。</li><li>最复杂的是要删除的节点左右子树都不为空的情况，可以用一个小技巧：找到要删除节点的下一个更大节点，它的位置在其右子树的最左叶子节点，设为 p 节点，用 p 节点的值覆盖要删除的节点的值，这时 p 节点的值出现了 2 次，然后转而去右子树删除 p 节点的值。</li></ol><h4 id=代码-12>代码</h4><div class=highlight id=id-35><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public TreeNode deleteNode(TreeNode root, int key) {
</span></span><span class=line><span class=cl>        if (root == null) {
</span></span><span class=line><span class=cl>            return null;
</span></span><span class=line><span class=cl>        } else if (root.val == key) {
</span></span><span class=line><span class=cl>            if (root.left == null || root.right == null) {
</span></span><span class=line><span class=cl>                return root.left == null ? root.right : root.left;
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                // 把右子树最左结点移到当前位置
</span></span><span class=line><span class=cl>                TreeNode p = root.right;
</span></span><span class=line><span class=cl>                while (p.left != null) {
</span></span><span class=line><span class=cl>                    p = p.left;
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                // 把要删除的值先覆盖，此时这个值出现 2 次， 去右子树删除多余的节点
</span></span><span class=line><span class=cl>                root.val = p.val;
</span></span><span class=line><span class=cl>                root.right = deleteNode(root.right, p.val);
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        } else if (root.val &lt; key) {
</span></span><span class=line><span class=cl>            root.right = deleteNode(root.right, key);
</span></span><span class=line><span class=cl>        } else if (root.val &gt; key) {
</span></span><span class=line><span class=cl>            root.left = deleteNode(root.left, key);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return root;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-13>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=102二叉树的层序遍历java>[102]二叉树的层序遍历.java</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><h4 id=思路-11>思路</h4><ol><li>构建一个队列，初始化时将根结点入队；</li><li>每个节点出队时，将它的子节点按先左后右的顺序入队；</li><li>只要队列非空就重复以上步骤。</li></ol><h4 id=代码-13>代码</h4><div class=highlight id=id-36><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
</span></span><span class=line><span class=cl>        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();
</span></span><span class=line><span class=cl>        if (root == null) {
</span></span><span class=line><span class=cl>            return res;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); // 核心数据结构
</span></span><span class=line><span class=cl>        q.offer(root); // 将起点加入队列
</span></span><span class=line><span class=cl>        while (!q.isEmpty()) {
</span></span><span class=line><span class=cl>            int size = q.size();
</span></span><span class=line><span class=cl>            List&lt;Integer&gt; row = new LinkedList&lt;&gt;();
</span></span><span class=line><span class=cl>            for (int i = 0; i &lt; size; i++) {
</span></span><span class=line><span class=cl>                TreeNode cur = q.poll();
</span></span><span class=line><span class=cl>                row.add(cur.val);
</span></span><span class=line><span class=cl>                if (cur.left != null) {
</span></span><span class=line><span class=cl>                    q.offer(cur.left);
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                if (cur.right != null) {
</span></span><span class=line><span class=cl>                    q.offer(cur.right);
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            res.add(row);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-14>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=752打开转盘锁java>[752]打开转盘锁.java</h3><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &lsquo;0&rsquo;, &lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;, &lsquo;5&rsquo;, &lsquo;6&rsquo;, &lsquo;7&rsquo;, &lsquo;8&rsquo;, &lsquo;9&rsquo;。每个拨轮可以自由旋转：例如把 &lsquo;9&rsquo; 变为 &lsquo;0&rsquo;，&lsquo;0&rsquo; 变为 &lsquo;9&rsquo; 。每次旋转都只能旋转一个拨轮的一位数字。
锁的初始数字为 &lsquo;0000&rsquo; ，一个代表四个拨轮的数字的字符串。
列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p><h4 id=思路-12>思路</h4><ol><li>运用 BFS 框架，构建一个队列，每当一个字符串出队，就将改变 4 个密码位的 8 种情况入队，每判断一层，计数自增，当出队值等于目标值时返回计数，否则最终返回 -1；</li><li>针对字符串中的某一位操作，可以抽一个方法出来；</li><li>题目还给了一组死亡数字，当出队字符串包含其中时，就跳过，说明走到了死胡同；</li><li>当出队的字符串不是最终目标时，就把它加入死亡数字，这样可以防止重复访问，走入死循环。</li></ol><h4 id=代码-14>代码</h4><div class=highlight id=id-37><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int openLock(String[] deadends, String target) {
</span></span><span class=line><span class=cl>        Queue&lt;String&gt; q = new LinkedList&lt;&gt;();
</span></span><span class=line><span class=cl>        Set&lt;String&gt; set = new HashSet&lt;&gt;();
</span></span><span class=line><span class=cl>        for (String deadend : deadends) {
</span></span><span class=line><span class=cl>            set.add(deadend);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        q.offer(&#34;0000&#34;);
</span></span><span class=line><span class=cl>        int count = 0;
</span></span><span class=line><span class=cl>        while (!q.isEmpty()) {
</span></span><span class=line><span class=cl>            int size = q.size();
</span></span><span class=line><span class=cl>            for (int i = 0; i &lt; size; i++) {
</span></span><span class=line><span class=cl>                String cur = q.poll();
</span></span><span class=line><span class=cl>                if (cur.equals(target)) {
</span></span><span class=line><span class=cl>                    return count;
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                if (set.contains(cur)) {
</span></span><span class=line><span class=cl>                    continue;
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                set.add(cur);
</span></span><span class=line><span class=cl>                for (int j = 0; j &lt; 4; j++) {
</span></span><span class=line><span class=cl>                    q.offer(operateOne(cur, j, 1));
</span></span><span class=line><span class=cl>                    q.offer(operateOne(cur, j, -1));
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            count++;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return -1;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * 改变字符串中的某一位
</span></span><span class=line><span class=cl>     *
</span></span><span class=line><span class=cl>     * @param s      字符串
</span></span><span class=line><span class=cl>     * @param index  哪一位
</span></span><span class=line><span class=cl>     * @param change 改变多少 （对于转盘锁只能传入 +1 或 -1）
</span></span><span class=line><span class=cl>     * @return
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    private String operateOne(String s, int index, int change) {
</span></span><span class=line><span class=cl>        char[] ch = s.toCharArray();
</span></span><span class=line><span class=cl>        if (ch[index] == &#39;9&#39; &amp;&amp; change == 1) {
</span></span><span class=line><span class=cl>            ch[index] = &#39;0&#39;;
</span></span><span class=line><span class=cl>        } else if (ch[index] == &#39;0&#39; &amp;&amp; change == -1) {
</span></span><span class=line><span class=cl>            ch[index] = &#39;9&#39;;
</span></span><span class=line><span class=cl>        } else {
</span></span><span class=line><span class=cl>            ch[index] += change;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return new String(ch);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-15>复杂度</h4><p>因为数字的进制、转盘的位数都是常数，</p><ul><li>时间复杂度：O(deadends.length)</li><li>空间复杂度：O(deadends.length)</li></ul><h3 id=662二叉树最大宽度java>[662]二叉树最大宽度.java</h3><p>//给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。 //// 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。 //// 示例 1: //// //输入: //// 1// / // 3 2// / \ // 5 3 9 ////输出: 4//解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。</p><div class=highlight id=id-38><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    int maxWidth;
</span></span><span class=line><span class=cl>    Map&lt;Integer, Integer&gt; leftmostPositions;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public int widthOfBinaryTree(TreeNode root) {
</span></span><span class=line><span class=cl>        maxWidth = 0;
</span></span><span class=line><span class=cl>        leftmostPositions = new HashMap&lt;&gt;();
</span></span><span class=line><span class=cl>        getWidth(root, 0, 0);
</span></span><span class=line><span class=cl>        return maxWidth;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private void getWidth(TreeNode node, int depth, int position) {
</span></span><span class=line><span class=cl>        if (node == null) return;
</span></span><span class=line><span class=cl>        // 不存在该层，则初始化
</span></span><span class=line><span class=cl>        leftmostPositions.computeIfAbsent(depth, key -&gt; position);
</span></span><span class=line><span class=cl>        maxWidth = Math.max(maxWidth, position - leftmostPositions.get(depth) + 1);
</span></span><span class=line><span class=cl>        // 当前节点的左右边界
</span></span><span class=line><span class=cl>        getWidth(node.left, depth + 1, position * 2);
</span></span><span class=line><span class=cl>        getWidth(node.right, depth + 1, position * 2 + 1);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=199二叉树的右视图java>[199]二叉树的右视图.java</h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><div class=highlight id=id-39><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public List&lt;Integer&gt; rightSideView(TreeNode root) {
</span></span><span class=line><span class=cl>        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();
</span></span><span class=line><span class=cl>        if (root == null) return result;
</span></span><span class=line><span class=cl>        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
</span></span><span class=line><span class=cl>        queue.offer(root);
</span></span><span class=line><span class=cl>        while (!queue.isEmpty()) {
</span></span><span class=line><span class=cl>            int size = queue.size();
</span></span><span class=line><span class=cl>            for (int i = 0; i &lt; size; i++) {
</span></span><span class=line><span class=cl>                TreeNode currentNode = queue.poll();
</span></span><span class=line><span class=cl>                if (i == 0) result.add(currentNode.val);
</span></span><span class=line><span class=cl>              // 入队：先右后左；否则就取 i == size -1 也可以
</span></span><span class=line><span class=cl>                if (currentNode.right != null) queue.offer(currentNode.right);
</span></span><span class=line><span class=cl>                if (currentNode.left != null) queue.offer(currentNode.left);
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return result;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=236二叉树的最近公共祖先java>[236]二叉树的最近公共祖先.java</h3><div class=highlight id=id-40><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>TreeNode</span><span class=w> </span><span class=nf>lowestCommonAncestor</span><span class=p>(</span><span class=n>TreeNode</span><span class=w> </span><span class=n>root</span><span class=p>,</span><span class=w> </span><span class=n>TreeNode</span><span class=w> </span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>TreeNode</span><span class=w> </span><span class=n>q</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>root</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>q</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>root</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TreeNode</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lowestCommonAncestor</span><span class=p>(</span><span class=n>root</span><span class=p>.</span><span class=na>left</span><span class=p>,</span><span class=w> </span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>q</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TreeNode</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lowestCommonAncestor</span><span class=p>(</span><span class=n>root</span><span class=p>.</span><span class=na>right</span><span class=p>,</span><span class=w> </span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=n>q</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>left</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>right</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>left</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>root</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=449-序列化和反序列化二叉搜索树java>[449] 序列化和反序列化二叉搜索树.java</h3><div class=highlight id=id-41><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Codec</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Encodes a tree to a single string.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>serialize</span><span class=p>(</span><span class=n>TreeNode</span><span class=w> </span><span class=n>root</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>StringBuilder</span><span class=w> </span><span class=n>sb</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>StringBuilder</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>serialize</span><span class=p>(</span><span class=n>root</span><span class=p>,</span><span class=n>sb</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>sb</span><span class=p>.</span><span class=na>toString</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>serialize</span><span class=p>(</span><span class=n>TreeNode</span><span class=w> </span><span class=n>root</span><span class=p>,</span><span class=n>StringBuilder</span><span class=w> </span><span class=n>sb</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=p>(</span><span class=n>root</span><span class=w> </span><span class=o>==</span><span class=kc>null</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>sb</span><span class=p>.</span><span class=na>append</span><span class=p>(</span><span class=s>&#34;null#&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>sb</span><span class=p>.</span><span class=na>append</span><span class=p>(</span><span class=n>root</span><span class=p>.</span><span class=na>val</span><span class=p>).</span><span class=na>append</span><span class=p>(</span><span class=s>&#34;#&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>serialize</span><span class=p>(</span><span class=n>root</span><span class=p>.</span><span class=na>left</span><span class=p>,</span><span class=n>sb</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>serialize</span><span class=p>(</span><span class=n>root</span><span class=p>.</span><span class=na>right</span><span class=p>,</span><span class=n>sb</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Decodes your encoded data to tree.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>TreeNode</span><span class=w> </span><span class=nf>deserialize</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>data</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>splits</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>data</span><span class=p>.</span><span class=na>split</span><span class=p>(</span><span class=s>&#34;#&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>split</span><span class=p>:</span><span class=n>splits</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>q</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=n>split</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>deserialize</span><span class=p>(</span><span class=n>q</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>TreeNode</span><span class=w> </span><span class=nf>deserialize</span><span class=p>(</span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>q</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>cur</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>q</span><span class=p>.</span><span class=na>poll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=p>(</span><span class=s>&#34;null&#34;</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>cur</span><span class=p>)){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TreeNode</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>TreeNode</span><span class=p>(</span><span class=n>Integer</span><span class=p>.</span><span class=na>valueOf</span><span class=p>(</span><span class=n>cur</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>root</span><span class=p>.</span><span class=na>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>deserialize</span><span class=p>(</span><span class=n>q</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>root</span><span class=p>.</span><span class=na>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>deserialize</span><span class=p>(</span><span class=n>q</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>root</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h2 id=滑动窗口>滑动窗口</h2><h3 id=模版>模版</h3><div class=highlight id=id-42><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* 滑动窗口算法框架 */
</span></span><span class=line><span class=cl>    void slidingWindow(String s, String t) {
</span></span><span class=line><span class=cl>        Map&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();
</span></span><span class=line><span class=cl>        Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; t.length(); i++) {
</span></span><span class=line><span class=cl>            char c = t.charAt(i);
</span></span><span class=line><span class=cl>            need.put(c, need.getOrDefault(c, 0) + 1);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        int left = 0, right = 0;
</span></span><span class=line><span class=cl>        int valid = 0;
</span></span><span class=line><span class=cl>        while (right &lt; s.length()) {
</span></span><span class=line><span class=cl>            // c 是将移入窗口的字符
</span></span><span class=line><span class=cl>            char c = s.charAt(right++);
</span></span><span class=line><span class=cl>            // todo 进行窗口内数据的一系列更新
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            // todo 判断左侧窗口是否要收缩
</span></span><span class=line><span class=cl>            while (window need shrink) {
</span></span><span class=line><span class=cl>                // d 是将移出窗口的字符
</span></span><span class=line><span class=cl>                char d = s.charAt(left++);
</span></span><span class=line><span class=cl>                // todo 进行窗口内数据的一系列更新
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }</span></span></code></pre></td></tr></table></div></div><ul><li>right：寻找可行解</li><li>left：试探最优解</li></ul><h3 id=3无重复字符的最长子串java>[3]无重复字符的最长子串.java</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><h4 id=思路-13>思路</h4><ul><li>right：寻找可行解：只要无重复字符就前进，一旦出现重复字符就停止，记录坐标</li><li>left：试探最优解：出现重复字符时前进，直到重复字符消失</li></ul><h4 id=代码-15>代码</h4><div class=highlight id=id-43><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>lengthOfLongestSubstring</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=na>length</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>Character</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>res</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>right</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>length</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// c 是将移入窗口的字符，右移窗口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>char</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>right</span><span class=o>++</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 进行窗口内数据的一系列更新</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>getOrDefault</span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>//  判断左侧窗口是否要收缩</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// d 是将移出窗口的字符，左移窗口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>char</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>left</span><span class=o>++</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 进行窗口内数据的一系列更新</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>d</span><span class=p>,</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>d</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>res</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>max</span><span class=p>(</span><span class=n>res</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>left</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>res</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-16>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=438找到字符串中所有字母异位词java>[438]找到字符串中所有字母异位词.java</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
异位词 指字母相同，但排列不同的字符串。</p><h4 id=思路-14>思路</h4><p>当窗口大小等于 p 的长度时，左右指针同时前进，寻找可行解。</p><h4 id=代码-16>代码</h4><div class=highlight id=id-44><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public List&lt;Integer&gt; findAnagrams(String s, String p) {
</span></span><span class=line><span class=cl>        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
</span></span><span class=line><span class=cl>        Map&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();
</span></span><span class=line><span class=cl>        Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; p.length(); i++) {
</span></span><span class=line><span class=cl>            char c = p.charAt(i);
</span></span><span class=line><span class=cl>            need.put(c, need.getOrDefault(c, 0) + 1);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        int left = 0, right = 0;
</span></span><span class=line><span class=cl>        int valid = 0;
</span></span><span class=line><span class=cl>        while (right &lt; s.length()) {
</span></span><span class=line><span class=cl>            // c 是将移入窗口的字符
</span></span><span class=line><span class=cl>            char c = s.charAt(right++);
</span></span><span class=line><span class=cl>            // 进行窗口内数据的一系列更新
</span></span><span class=line><span class=cl>            if (need.containsKey(c)) {
</span></span><span class=line><span class=cl>                window.put(c, window.getOrDefault(c, 0) + 1);
</span></span><span class=line><span class=cl>                if (window.get(c).equals(need.get(c))) {
</span></span><span class=line><span class=cl>                    valid++;
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            // 判断左侧窗口是否要收缩
</span></span><span class=line><span class=cl>            if (right - left == p.length()) {
</span></span><span class=line><span class=cl>                if (valid == need.size()) {
</span></span><span class=line><span class=cl>                    res.add(left);
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                // d 是将移出窗口的字符
</span></span><span class=line><span class=cl>                char d = s.charAt(left++);
</span></span><span class=line><span class=cl>                // 进行窗口内数据的一系列更新
</span></span><span class=line><span class=cl>                if (need.containsKey(d)) {
</span></span><span class=line><span class=cl>                    if (window.get(d).equals(need.get(d))) {
</span></span><span class=line><span class=cl>                        valid--;
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                    window.put(d, window.get(d) - 1);
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-17>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id=回溯>回溯</h2><h3 id=46全排列java>[46]全排列.java</h3><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><h4 id=思路-15>思路</h4><ol><li>定义结果集为全局变量；</li><li>核心是写出回溯函数，明确增添结果、退出递归的时机，向每一种可能的情况迈出一小步，进入下一次回溯，在最后还要归位；</li><li>正确的结果集：路径长度达到数字长度；</li><li>筛选条件：数字在路径中没有出现过；</li><li>对算法进行适当的剪枝，提高时间效率。</li></ol><h4 id=代码-17>代码</h4><div class=highlight id=id-45><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    // 结果集
</span></span><span class=line><span class=cl>    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
</span></span><span class=line><span class=cl>				// add、remove 不会影响new ArrayList 的浅拷贝
</span></span><span class=line><span class=cl>        backTrack(nums, new LinkedList&lt;&gt;());
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private void backTrack(int[] nums, LinkedList&lt;Integer&gt; path) {
</span></span><span class=line><span class=cl>        // 增添结果、退出递归
</span></span><span class=line><span class=cl>        if (path.size() == nums.length) {
</span></span><span class=line><span class=cl>            res.add(new ArrayList&lt;&gt;(path));
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; nums.length; i++) {
</span></span><span class=line><span class=cl>            // 筛选
</span></span><span class=line><span class=cl>            if (path.contains(nums[i])) {
</span></span><span class=line><span class=cl>                continue;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            // 试探步
</span></span><span class=line><span class=cl>            path.addLast(nums[i]);
</span></span><span class=line><span class=cl>            // 回溯
</span></span><span class=line><span class=cl>            backTrack(nums, path);
</span></span><span class=line><span class=cl>            // 归位
</span></span><span class=line><span class=cl>            path.removeLast();
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-18>复杂度</h4><ul><li>时间复杂度：O(n*n!)</li><li>空间复杂度：O(n)</li></ul><h3 id=51n-皇后java>[51]N 皇后.java</h3><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &lsquo;Q&rsquo; 和 &lsquo;.&rsquo; 分别代表了皇后和空位。</p><h4 id=思路-16>思路</h4><ol><li>定义结果集为全局变量；</li><li>核心是写出回溯函数，明确增添结果、退出递归的时机，向每一种通过筛选的情况迈出一小步，进入下一次回溯，在最后还要归位；</li><li>正确的结果集：第 8 行皇后符合要求；</li><li>筛选条件：任意两皇后不在同一行、同一列或同一斜线；</li><li>对算法进行适当的剪枝，提高时间效率。</li></ol><h4 id=代码-18>代码</h4><div class=highlight id=id-46><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    // 结果集
</span></span><span class=line><span class=cl>    private List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {
</span></span><span class=line><span class=cl>        // 初始化棋盘
</span></span><span class=line><span class=cl>        char[][] board = new char[n][n];
</span></span><span class=line><span class=cl>        for (char[] line : board) {
</span></span><span class=line><span class=cl>            Arrays.fill(line, &#39;.&#39;);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        backTrack(board, 0);
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private void backTrack(char[][] board, int row) {
</span></span><span class=line><span class=cl>        // 增添结果、退出递归
</span></span><span class=line><span class=cl>        if (row == board.length) {
</span></span><span class=line><span class=cl>            List&lt;String&gt; list = new ArrayList&lt;&gt;();
</span></span><span class=line><span class=cl>            for (char[] c : board) {
</span></span><span class=line><span class=cl>                list.add(String.copyValueOf(c));
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            res.add(list);
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        for (int col = 0; col &lt; board[row].length; col++) {
</span></span><span class=line><span class=cl>            // 筛选
</span></span><span class=line><span class=cl>            if (!isValid(board, row, col)) {
</span></span><span class=line><span class=cl>                continue;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            // 试探步
</span></span><span class=line><span class=cl>            board[row][col] = &#39;Q&#39;;
</span></span><span class=line><span class=cl>            // 回溯
</span></span><span class=line><span class=cl>            backTrack(board, row + 1);
</span></span><span class=line><span class=cl>            // 归位
</span></span><span class=line><span class=cl>            board[row][col] = &#39;.&#39;;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private boolean isValid(char[][] board, int row, int col) {
</span></span><span class=line><span class=cl>        int n = board.length;
</span></span><span class=line><span class=cl>        // 检查列是否有皇后冲突
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; n; i++) {
</span></span><span class=line><span class=cl>            if (board[i][col] == &#39;Q&#39;) {
</span></span><span class=line><span class=cl>                return false;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 检查右上方是否有皇后冲突
</span></span><span class=line><span class=cl>        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {
</span></span><span class=line><span class=cl>            if (board[i][j] == &#39;Q&#39;) {
</span></span><span class=line><span class=cl>                return false;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        // 检查左上方是否有皇后冲突
</span></span><span class=line><span class=cl>        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {
</span></span><span class=line><span class=cl>            if (board[i][j] == &#39;Q&#39;) {
</span></span><span class=line><span class=cl>                return false;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return true;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-19>复杂度</h4><ul><li>时间复杂度：O(n!)</li><li>空间复杂度：O(n)</li></ul><h3 id=22括号生成java>[22]括号生成.java</h3><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
有效括号组合需满足：左括号必须以正确的顺序闭合。</p><h4 id=思路-17>思路</h4><ol><li>以左右括号剩余数为筛选、判断的标准；</li><li>正确的结果集：左右括号剩余数都为 0；</li><li>筛选条件：左右括号剩余数都为非负数，且右括号剩余数不小于左括号剩余数；</li></ol><h4 id=代码-19>代码</h4><div class=highlight id=id-47><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    // 结果集
</span></span><span class=line><span class=cl>    List&lt;String&gt; res = new LinkedList&lt;&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public List&lt;String&gt; generateParenthesis(int n) {
</span></span><span class=line><span class=cl>        String curStr = &#34;&#34;;
</span></span><span class=line><span class=cl>        // 结果演进的起点是空字符串，左右各有n个括号
</span></span><span class=line><span class=cl>        backtrack(curStr, n, n);
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * 回溯法
</span></span><span class=line><span class=cl>     *
</span></span><span class=line><span class=cl>     * @param str   路径
</span></span><span class=line><span class=cl>     * @param left  左括号剩余数
</span></span><span class=line><span class=cl>     * @param right 右括号剩余数
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    private void backtrack(String str, int left, int right) {
</span></span><span class=line><span class=cl>        //边界条件 base case
</span></span><span class=line><span class=cl>        if (left == 0 &amp;&amp; right == 0) {
</span></span><span class=line><span class=cl>            res.add(str);
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        //减枝：左括号数必须大于等于右括号
</span></span><span class=line><span class=cl>        if (left &lt; 0 || right &lt; 0 || left &gt; right) {
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        if (left &gt; 0) {
</span></span><span class=line><span class=cl>            backtrack(str + &#34;(&#34;, left - 1, right);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        if (right &gt; 0) {
</span></span><span class=line><span class=cl>            backtrack(str + &#34;)&#34;, left, right - 1);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-20>复杂度</h4><ul><li>时间复杂度： O(C_{2n}^n)</li><li>空间复杂度：O(1)</li></ul><h3 id=039-组合总和>039 组合总和</h3><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。</p><h4 id=代码-20>代码</h4><div class=highlight id=id-48><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    // 结果集
</span></span><span class=line><span class=cl>    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
</span></span><span class=line><span class=cl>        if (candidates == null || candidates.length == 0) {
</span></span><span class=line><span class=cl>            return res;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        Arrays.sort(candidates);
</span></span><span class=line><span class=cl>        backTrack(new ArrayList&lt;&gt;(), 0, 0, candidates, target);
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private void backTrack(List&lt;Integer&gt; path, int sum, int idx, int[] candidates, int target) {
</span></span><span class=line><span class=cl>        // base case
</span></span><span class=line><span class=cl>        if (sum == target) {
</span></span><span class=line><span class=cl>            res.add(new ArrayList&lt;&gt;(path));
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        for (int i = idx; i &lt; candidates.length; i++) {
</span></span><span class=line><span class=cl>            // 减枝
</span></span><span class=line><span class=cl>            if (sum + candidates[i] &gt; target) {
</span></span><span class=line><span class=cl>                break;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            path.add(candidates[i]);
</span></span><span class=line><span class=cl>            backTrack(path, sum + candidates[i], i, candidates, target);
</span></span><span class=line><span class=cl>            path.remove(path.size() - 1);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-21>复杂度</h4><ul><li>时间复杂度：O(n*2^n)实际运行情况远远小于这个上界可表示为 O(S)，其中 S 为所有可行解的长度之和</li><li>空间复杂度：O(target)</li></ul><h3 id=040-组合总和>040 组合总和Ⅱ</h3><p>在 039 组合总和 的基础上，每个数字在每个组合中只能使用一次</p><h4 id=代码-21>代码</h4><div class=highlight id=id-49><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    // 结果集
</span></span><span class=line><span class=cl>    Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
</span></span><span class=line><span class=cl>        if (candidates == null || candidates.length == 0) {
</span></span><span class=line><span class=cl>            return new ArrayList&lt;&gt;(res);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        Arrays.sort(candidates);
</span></span><span class=line><span class=cl>        backTrack(new ArrayList&lt;&gt;(), 0, 0, candidates, target);
</span></span><span class=line><span class=cl>        // 返回值类型需要 Set 转 List
</span></span><span class=line><span class=cl>        return new ArrayList&lt;&gt;(res);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private void backTrack(List&lt;Integer&gt; path, int sum, int idx, int[] candidates, int target) {
</span></span><span class=line><span class=cl>        // base case
</span></span><span class=line><span class=cl>        if (sum == target) {
</span></span><span class=line><span class=cl>            res.add(new ArrayList&lt;&gt;(path));
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        for (int i = idx; i &lt; candidates.length; i++) {
</span></span><span class=line><span class=cl>            // 减枝
</span></span><span class=line><span class=cl>            if (sum + candidates[i] &gt; target) {
</span></span><span class=line><span class=cl>                break;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            path.add(candidates[i]);
</span></span><span class=line><span class=cl>            //回溯时用过的数字不能再用
</span></span><span class=line><span class=cl>            backTrack(path, sum + candidates[i], i + 1, candidates, target);
</span></span><span class=line><span class=cl>            path.remove(path.size() - 1);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-22>复杂度</h4><ul><li>时间复杂度：O(n*2^n)实际运行情况远远小于这个上界可表示为 O(S)，其中 S 为所有可行解的长度之和</li><li>空间复杂度：O(target)</li></ul><h3 id=046-全排列>046 全排列</h3><p>给定一个不含重复数字的数组 nums ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><h4 id=代码-22>代码</h4><div class=highlight id=id-50><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    // 结果集
</span></span><span class=line><span class=cl>    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
</span></span><span class=line><span class=cl>        backTrack(nums, new LinkedList&lt;&gt;());
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private void backTrack(int[] nums, LinkedList&lt;Integer&gt; path) {
</span></span><span class=line><span class=cl>        // 减枝
</span></span><span class=line><span class=cl>        if (path.size() == nums.length) {
</span></span><span class=line><span class=cl>            res.add(new ArrayList&lt;&gt;(path));
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; nums.length; i++) {
</span></span><span class=line><span class=cl>            // 筛选
</span></span><span class=line><span class=cl>            if (path.contains(nums[i])) {
</span></span><span class=line><span class=cl>                continue;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            path.addLast(nums[i]);
</span></span><span class=line><span class=cl>            backTrack(nums, path);
</span></span><span class=line><span class=cl>            path.removeLast();
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-23>复杂度</h4><ul><li>时间复杂度：O(n*n!)</li><li>空间复杂度：O(n)</li></ul><h3 id=047-全排列>047 全排列Ⅱ</h3><p>在 046 全排列 的基础上，nums可包含重复数字</p><h4 id=代码-23>代码</h4><div class=highlight id=id-51><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    // 结果集
</span></span><span class=line><span class=cl>    Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
</span></span><span class=line><span class=cl>        backTrack(nums, new LinkedList&lt;&gt;(), new boolean[nums.length]);
</span></span><span class=line><span class=cl>        return new ArrayList&lt;&gt;(res);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private void backTrack(int[] nums, LinkedList&lt;Integer&gt; path, boolean[] used) {
</span></span><span class=line><span class=cl>        // 减枝
</span></span><span class=line><span class=cl>        if (path.size() == nums.length) {
</span></span><span class=line><span class=cl>            res.add(new ArrayList&lt;&gt;(path));
</span></span><span class=line><span class=cl>            return;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; nums.length; i++) {
</span></span><span class=line><span class=cl>            // 筛选
</span></span><span class=line><span class=cl>            if (used[i]) {
</span></span><span class=line><span class=cl>                continue;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            path.addLast(nums[i]);
</span></span><span class=line><span class=cl>            used[i] = true;
</span></span><span class=line><span class=cl>            backTrack(nums, path, used);
</span></span><span class=line><span class=cl>            path.removeLast();
</span></span><span class=line><span class=cl>            used[i] = false;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-24>复杂度</h4><ul><li>时间复杂度：O(n*n!)</li><li>空间复杂度：O(n)</li></ul><h2 id=动态规划>动态规划</h2><h3 id=53最大子序和java>[53]最大子序和.java</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><h4 id=思路-18>思路</h4><p>因为，某一位的最大子序和无非两种情况</p><ol><li>继续累加前一个数的最大子序和</li><li>从当前数字重新累加</li></ol><p>所以，得到状态转移方程：
f(i)=max({f(i−1)+nums[i],nums[i]})</p><h4 id=代码-24>代码</h4><div class=highlight id=id-52><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int maxSubArray(int[] nums) {
</span></span><span class=line><span class=cl>        int pre = 0, maxAns = nums[0];
</span></span><span class=line><span class=cl>        for (int x : nums) {
</span></span><span class=line><span class=cl>            pre = Math.max(pre + x, x);
</span></span><span class=line><span class=cl>            maxAns = Math.max(maxAns, pre);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return maxAns;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int maxSubArray(int[] nums) {
</span></span><span class=line><span class=cl>        int left = 0, right = 0, sum = 0, res = Integer.MIN_VALUE;
</span></span><span class=line><span class=cl>        while (right &lt; nums.length) {
</span></span><span class=line><span class=cl>            sum += nums[right++];
</span></span><span class=line><span class=cl>            while (sum &lt; 0) {
</span></span><span class=line><span class=cl>                // d 是将移出窗口的字符
</span></span><span class=line><span class=cl>                sum -= nums[left++];
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            res = Math.max(sum, res);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        int negative = Integer.MIN_VALUE;
</span></span><span class=line><span class=cl>        for (int num : nums) {
</span></span><span class=line><span class=cl>            negative = Math.max(num, negative);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return negative &lt; 0 ? negative : res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-25>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=300最长递增子序列java>[300]最长递增子序列.java</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><h4 id=思路-19>思路</h4><p>因为，某一位的最大子序长度无非两种情况</p><ol><li>先在前面找出比当前数字更小的数字，找一个长度最长的自增 1 作为当前的最大自序长度</li><li>从当前数字重新累加（可以让初始化长度为1）</li></ol><h4 id=代码-25>代码</h4><div class=highlight id=id-53><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int lengthOfLIS(int[] nums) {
</span></span><span class=line><span class=cl>        final int n = nums.length;
</span></span><span class=line><span class=cl>        int[] dp = new int[n];
</span></span><span class=line><span class=cl>        // base case：dp 数组全都初始化为 1
</span></span><span class=line><span class=cl>        Arrays.fill(dp, 1);
</span></span><span class=line><span class=cl>        int res = 0;
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; n; i++) {
</span></span><span class=line><span class=cl>            // 在前面找比当前数字更小的数字，以满足递增子序列的要求。
</span></span><span class=line><span class=cl>            int cur = nums[i];
</span></span><span class=line><span class=cl>            for (int j = 0; j &lt; i; j++) {
</span></span><span class=line><span class=cl>                if (nums[j] &lt; cur)
</span></span><span class=line><span class=cl>                    dp[i] = Math.max(dp[i], dp[j] + 1);
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            // 更新最大值作为返回结果
</span></span><span class=line><span class=cl>            res = Math.max(res, dp[i]);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-26>复杂度</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)</li></ul><h2 id=栈和队列>栈和队列</h2><h3 id=225用队列实现栈java>[225]用队列实现栈.java</h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><h4 id=思路-20>思路</h4><ol><li>用一个全局变量记录栈顶。</li><li>入栈、判空不做处理</li><li>额外处理出栈的 pop 操作，把队列中前 n-1 个元素出队再入队，返回末尾元素。</li></ol><h4 id=代码-26>代码</h4><div class=highlight id=id-54><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class MyStack {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Queue&lt;Integer&gt; queue;
</span></span><span class=line><span class=cl>    int top;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Initialize your data structure here.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public MyStack() {
</span></span><span class=line><span class=cl>        queue = new LinkedList&lt;&gt;();
</span></span><span class=line><span class=cl>        top = 0;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Push element x onto stack.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public void push(int x) {
</span></span><span class=line><span class=cl>        queue.offer(x);
</span></span><span class=line><span class=cl>        top = x;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Removes the element on top of the stack and returns that element.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public int pop() {
</span></span><span class=line><span class=cl>        int size = queue.size();
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; size - 1; i++) {
</span></span><span class=line><span class=cl>            top = queue.peek();
</span></span><span class=line><span class=cl>            queue.offer(queue.poll());
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return queue.poll();
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Get the top element.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public int top() {
</span></span><span class=line><span class=cl>        return top;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Returns whether the stack is empty.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public boolean empty() {
</span></span><span class=line><span class=cl>        return queue.isEmpty();
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=232用栈实现队列java>[232]用栈实现队列.java</h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）</p><h4 id=思路-21>思路</h4><ol><li>建立 2 个栈，元素先入 s1，再入 s2，这样 s2 的栈顶就相当于队尾了。</li><li>把关键操作放在 peek 处，在 pop 之前，先调用 peek ，就能确保不会出错了。</li></ol><h4 id=代码-27>代码</h4><div class=highlight id=id-55><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class MyQueue {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    private Stack&lt;Integer&gt; s1, s2;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Initialize your data structure here.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public MyQueue() {
</span></span><span class=line><span class=cl>        s1 = new Stack&lt;&gt;();
</span></span><span class=line><span class=cl>        s2 = new Stack&lt;&gt;();
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Push element x to the back of queue.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public void push(int x) {
</span></span><span class=line><span class=cl>        s1.push(x);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Removes the element from in front of queue and returns that element.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public int pop() {
</span></span><span class=line><span class=cl>        // 将 s1 元素转移至 s2
</span></span><span class=line><span class=cl>        peek();
</span></span><span class=line><span class=cl>        return s2.pop();
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Get the front element.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public int peek() {
</span></span><span class=line><span class=cl>        if (s2.isEmpty()) {
</span></span><span class=line><span class=cl>            while (!s1.isEmpty()) {
</span></span><span class=line><span class=cl>                s2.push(s1.pop());
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return s2.peek();
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /**
</span></span><span class=line><span class=cl>     * Returns whether the queue is empty.
</span></span><span class=line><span class=cl>     */
</span></span><span class=line><span class=cl>    public boolean empty() {
</span></span><span class=line><span class=cl>        return s1.isEmpty() &amp;&amp; s2.isEmpty();
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h3 id=496下一个更大元素-ijava>[496]下一个更大元素 I.java</h3><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。
请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><h4 id=思路-22>思路</h4><ol><li>从后往前遍历 nums2，用栈记录右侧大于当前数字的值；</li><li>以当前数字为 key，下一个更大元素为 value，建立一个 HashMap 存储；</li><li>遍历 nums1 ,获取每一个 key 的 value。</li></ol><h4 id=代码-28>代码</h4><div class=highlight id=id-56><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
</span></span><span class=line><span class=cl>        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
</span></span><span class=line><span class=cl>        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
</span></span><span class=line><span class=cl>        // 从后往前遍历
</span></span><span class=line><span class=cl>        for (int i = nums2.length - 1; i &gt;= 0; i--) {
</span></span><span class=line><span class=cl>            while (!stack.isEmpty() &amp;&amp; nums2[i] &gt;= stack.peek()) {
</span></span><span class=line><span class=cl>                // 栈顶元素即将被 nums2[i] 挡住
</span></span><span class=line><span class=cl>                stack.pop();
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            int nextGreaterNum = stack.isEmpty() ? -1 : stack.peek();
</span></span><span class=line><span class=cl>            map.put(nums2[i], nextGreaterNum);
</span></span><span class=line><span class=cl>            stack.push(nums2[i]);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        int[] res = new int[nums1.length];
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; nums1.length; i++) {
</span></span><span class=line><span class=cl>            res[i] = map.get(nums1[i]);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-27>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=503下一个更大元素-iijava>[503]下一个更大元素 II.java</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><h4 id=思路-23>思路</h4><ol><li>从后往前遍历 nums，用栈记录右侧大于当前数字的值</li><li>因为数组是循环数组，所以在赋值 -1 时还要去坐标左边找找，如果还找不到更大元素，那么就返回 -1，否则就返回第一个更大元素。</li></ol><h4 id=代码-29>代码</h4><div class=highlight id=id-57><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int[] nextGreaterElements(int[] nums) {
</span></span><span class=line><span class=cl>        int[] res = new int[nums.length];
</span></span><span class=line><span class=cl>        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
</span></span><span class=line><span class=cl>        // 从后往前遍历
</span></span><span class=line><span class=cl>        for (int i = nums.length - 1; i &gt;= 0; i--) {
</span></span><span class=line><span class=cl>            while (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) {
</span></span><span class=line><span class=cl>                // 栈顶元素即将被 nums[i] 挡住
</span></span><span class=line><span class=cl>                stack.pop();
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            if (stack.isEmpty()) {
</span></span><span class=line><span class=cl>                res[i] = -1;
</span></span><span class=line><span class=cl>                // 后面找不到了，去前面找找看
</span></span><span class=line><span class=cl>                for (int j = 0; j &lt; i; j++) {
</span></span><span class=line><span class=cl>                    if (nums[j] &gt; nums[i]) {
</span></span><span class=line><span class=cl>                        res[i] = nums[j];
</span></span><span class=line><span class=cl>                        break;
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                res[i] = stack.peek();
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            stack.push(nums[i]);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public int[] nextGreaterElements(int[] nums) {
</span></span><span class=line><span class=cl>        int n = nums.length;
</span></span><span class=line><span class=cl>        int[] res = new int[n];
</span></span><span class=line><span class=cl>        Arrays.fill(res, -1);
</span></span><span class=line><span class=cl>        // 单调栈中存放下标
</span></span><span class=line><span class=cl>        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
</span></span><span class=line><span class=cl>        for (int i = 0; i &lt; n * 2; i++) {
</span></span><span class=line><span class=cl>            while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i % n]) {
</span></span><span class=line><span class=cl>                // 出栈的值的下一个更大元素即为 nums[i]
</span></span><span class=line><span class=cl>                res[stack.pop()] = nums[i % n];
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            if (i &lt; n) {
</span></span><span class=line><span class=cl>                stack.push(i);
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-28>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=1047删除字符串中的所有相邻重复项java>[1047]删除字符串中的所有相邻重复项.java</h3><p>//给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 //// 在 S 上反复执行重复项删除操作，直到无法继续删除。 //// 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 //// //// 示例： //// 输入：&ldquo;abbaca&rdquo;//输出：&ldquo;ca&rdquo;//解释：//例如，在 &ldquo;abbaca&rdquo; 中，我们可以删除 &ldquo;bb&rdquo; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &ldquo;aaca&rdquo;，其中又//只有 &ldquo;aa&rdquo; 可以执行重复项删除操作，所以最后的字符串为 &ldquo;ca&rdquo;。</p><div class=highlight id=id-58><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public String removeDuplicates(String s) {
</span></span><span class=line><span class=cl>        char[] stack = new char[s.length()];
</span></span><span class=line><span class=cl>        int index = 0;
</span></span><span class=line><span class=cl>        for (char currentChar : s.toCharArray()) {
</span></span><span class=line><span class=cl>            if (index &gt; 0 &amp;&amp; stack[index - 1] == currentChar) {
</span></span><span class=line><span class=cl>                index--;
</span></span><span class=line><span class=cl>            } else {
</span></span><span class=line><span class=cl>                stack[index++] = currentChar;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return new String(stack, 0, index);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h2 id=其他>其他</h2><h3 id=并查集union-find算法990等式方程的可满足性java>并查集（Union-Find）算法：[990]等式方程的可满足性.java</h3><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：&ldquo;a==b&rdquo; 或 &ldquo;a!=b&rdquo;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p><h4 id=思路-24>思路</h4><ol><li>将方程分成等式和不等式两类；</li><li>初始化「图」；</li><li>根据等式连接两两节点；</li><li>判断不等式是否成立。</li></ol><h4 id=代码-30>代码</h4><div class=highlight id=id-59><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 节点 x 的节点是 parent[x]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>parent</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 新增一个数组记录树的“重量”</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>size</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>equationsPossible</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>equations</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 1. 将方程分成等式和不等式两类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>equals</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>unEquals</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>equation</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>equations</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>char</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>equation</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;=&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>equals</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>equation</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;!&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>unEquals</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>equation</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 2. 初始化「图」</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>parent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>26</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>26</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>26</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 父节点指针初始指向自己</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>parent</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 重量应该初始化 1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>size</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 3. 根据等式连接两两节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>equal</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>equals</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>equal</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>equal</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>3</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>union</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 4. 判断不等式是否成立</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>unEqual</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>unEquals</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>unEqual</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>unEqual</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>3</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=sc>&#39;a&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>rootA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>find</span><span class=p>(</span><span class=n>a</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>rootB</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>find</span><span class=p>(</span><span class=n>b</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>rootA</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>rootB</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/* 将 p 和 q 连接 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>union</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>p</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>q</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>rootP</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>find</span><span class=p>(</span><span class=n>p</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>rootQ</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>find</span><span class=p>(</span><span class=n>q</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>rootP</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>rootQ</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 二者已连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 将两棵树合并为一棵，小树接到大树下面</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>size</span><span class=o>[</span><span class=n>rootP</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>size</span><span class=o>[</span><span class=n>rootQ</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>parent</span><span class=o>[</span><span class=n>rootQ</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rootP</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>size</span><span class=o>[</span><span class=n>rootP</span><span class=o>]</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>size</span><span class=o>[</span><span class=n>rootQ</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>parent</span><span class=o>[</span><span class=n>rootP</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rootQ</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>size</span><span class=o>[</span><span class=n>rootQ</span><span class=o>]</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>size</span><span class=o>[</span><span class=n>rootP</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/* 返回某个节点 x 的根节点 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>find</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 根节点的 parent[x] == x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>parent</span><span class=o>[</span><span class=n>x</span><span class=o>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>parent</span><span class=o>[</span><span class=n>x</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parent</span><span class=o>[</span><span class=n>parent</span><span class=o>[</span><span class=n>x</span><span class=o>]]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parent</span><span class=o>[</span><span class=n>x</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-29>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=050-powxn>050 Pow(x,n)</h3><h4 id=int转换为long>int转换为long</h4><p>Java 代码中 int32 变量 n \in [-2147483648, 2147483647]，因此当 n = -2147483648 时执行 n = -n会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可。</p><h4 id=代码迭代>代码（迭代）</h4><div class=highlight id=id-60><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Solution {
</span></span><span class=line><span class=cl>    public double myPow(double x, int n) {
</span></span><span class=line><span class=cl>        if (x == 0.0f) return 0.0d;
</span></span><span class=line><span class=cl>        //防止n=-n赋值越界
</span></span><span class=line><span class=cl>        long b = n;
</span></span><span class=line><span class=cl>        // n=0情况返回1
</span></span><span class=line><span class=cl>        double res = 1.0;
</span></span><span class=line><span class=cl>        if (b &lt; 0) {
</span></span><span class=line><span class=cl>            x = 1 / x;
</span></span><span class=line><span class=cl>            b = -b;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        while (b &gt; 0) {
</span></span><span class=line><span class=cl>            if ((b &amp; 1) == 1) {
</span></span><span class=line><span class=cl>                //奇数
</span></span><span class=line><span class=cl>                res *= x;
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            x *= x;
</span></span><span class=line><span class=cl>            //按位右移，相当于除以2
</span></span><span class=line><span class=cl>            b &gt;&gt;= 1;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        return res;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><h4 id=复杂度-30>复杂度</h4><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2022-06-08 08:08:08">更新于 2022-06-08&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://leni.fun/leetcode/ data-title="LeetCode 大全"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/leetcode/ class=post-tag>LeetCode</a><a href=/tags/ds/ class=post-tag>DS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/zookeeper_draft/ class=post-nav-item rel=prev title="Zookeeper 杂记"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Zookeeper 杂记</a>
<a href=/rpc_draft/ class=post-nav-item rel=next title="RPC 杂记">RPC 杂记<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line copyright order-5" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2021 - 2023</span><span class=author itemprop=copyrightHolder>
<a href=/>都将会</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://beian.miit.gov.cn target=_blank>浙ICP备2023023782号</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-4"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/hihihiman/hihihiman.github.io title=博客源码 target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;bottom:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/pink/pace-theme-center-atom.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/fuse/fuse.min.js defer></script><script src=/lib/lightgallery/lightgallery.min.js defer></script><script src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/typeit/index.umd.js defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:1024},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},data:{"typeit-header-subtitle-desktop":"的博客           ","typeit-header-subtitle-mobile":"的博客           "},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{distance:100,findAllMatches:!1,highlightTag:"em",ignoreFieldNorm:!0,ignoreLocation:!0,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,useExtendedSearch:!0},siteTime:"2021-08-26T23:31:00+08:00",typeit:{cursorChar:"_",cursorSpeed:1e3,data:{"typeit-header-subtitle-desktop":["typeit-header-subtitle-desktop"],"typeit-header-subtitle-mobile":["typeit-header-subtitle-mobile"]},duration:-1,loop:!0,speed:150}}</script><script src=/js/theme.min.js defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js></script><script type=text/javascript src=/js/custom.js></script></body></html>