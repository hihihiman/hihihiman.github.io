<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>LeetCode - 标签 -</title><link>https://leni.fun/tags/leetcode/</link><description>LeetCode - 标签 -</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>dujianghui_work@163.com (都将会)</managingEditor><webMaster>dujianghui_work@163.com (都将会)</webMaster><lastBuildDate>Thu, 08 Feb 2024 08:08:08 +0800</lastBuildDate><atom:link href="https://leni.fun/tags/leetcode/" rel="self" type="application/rss+xml"/><item><title>🚩LeetCode 典中典</title><link>https://leni.fun/leetcode-%E5%85%B8%E4%B8%AD%E5%85%B8/</link><pubDate>Thu, 08 Feb 2024 08:08:08 +0800</pubDate><author>都将会</author><guid>https://leni.fun/leetcode-%E5%85%B8%E4%B8%AD%E5%85%B8/</guid><description><![CDATA[<div class="featured-image">
        <img src="/images/pic32.jpg" referrerpolicy="no-referrer">
      </div>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public static void quickSort(int[] nums, int left, int right) { if (left &lt; right) { // 基准点 int pivot = partition(nums, left, right); // 分治递归 quickSort(nums, left, pivot - 1); quickSort(nums, pivot + 1, right); }]]></description></item><item><title>LRU和LFU的实现原理</title><link>https://leni.fun/lrulfu/</link><pubDate>Mon, 21 Aug 2023 08:08:08 +0800</pubDate><author>都将会</author><guid>https://leni.fun/lrulfu/</guid><description>&lt;div class="featured-image">
&lt;img src="/images/pic9.jpg" referrerpolicy="no-referrer">
&lt;/div>[146]LRU 缓存机制.java 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 ，实现 LRUCache 类： LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果</description></item><item><title>🚩DP - 动态规划</title><link>https://leni.fun/dp/</link><pubDate>Sun, 20 Aug 2023 11:20:24 +0800</pubDate><author>都将会</author><guid>https://leni.fun/dp/</guid><description><![CDATA[<div class="featured-image">
        <img src="/images/pic8.jpg" referrerpolicy="no-referrer">
      </div><p>最近发现笔试题的区分度主要在动态规划，本文按照题型归类整理。</p>]]></description></item><item><title>往期周赛与笔试题解</title><link>https://leni.fun/%E5%BE%80%E6%9C%9F%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/</link><pubDate>Sun, 09 Jul 2023 08:08:08 +0800</pubDate><author>都将会</author><guid>https://leni.fun/%E5%BE%80%E6%9C%9F%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/</guid><description><![CDATA[20230709 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public static int maximumJumps(int[] nums, int target) { int len = nums.length; int[] dp = new int[len]; for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; i; j++) { if (Math.abs(nums[j] - nums[i]) &lt;= target){ if (dp[j] == 0 &amp;&amp; j != 0)]]></description></item><item><title>LeetCode 大全</title><link>https://leni.fun/leetcode/</link><pubDate>Wed, 08 Jun 2022 08:08:08 +0800</pubDate><author>都将会</author><guid>https://leni.fun/leetcode/</guid><description>数组 [560]和为K的子数组.java 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 思路 采用空间换时间策略，用</description></item></channel></rss>