<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>LeetCode 大全 -</title><meta name=author content="都将会"><meta name=author-link content><meta name=description content="常回来看看"><meta name=keywords content="LeetCode,practice,面试"><meta itemprop=name content="LeetCode 大全"><meta itemprop=description content="常回来看看"><meta itemprop=datePublished content="2023-08-08T15:51:32+08:00"><meta itemprop=dateModified content="2023-08-08T15:51:32+08:00"><meta itemprop=wordCount content="7092"><meta itemprop=image content="https://leni.fun/images/avatar.jpg"><meta itemprop=keywords content="LeetCode,DS,"><meta property="og:title" content="LeetCode 大全"><meta property="og:description" content="常回来看看"><meta property="og:type" content="article"><meta property="og:url" content="https://leni.fun/posts/leetcode/"><meta property="og:image" content="https://leni.fun/images/avatar.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-08T15:51:32+08:00"><meta property="article:modified_time" content="2023-08-08T15:51:32+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://leni.fun/images/avatar.jpg"><meta name=twitter:title content="LeetCode 大全"><meta name=twitter:description content="常回来看看"><meta name=application-name content="都将会的 APP"><meta name=apple-mobile-web-app-title content="都将会的 APP"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://leni.fun/posts/leetcode/><link rel=prev href=https://leni.fun/posts/kaggle/><link rel=next href=https://leni.fun/posts/lfu/><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"LeetCode 大全","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/leni.fun\/posts\/leetcode\/"},"genre":"posts","keywords":"LeetCode, DS","wordcount":7092,"url":"https:\/\/leni.fun\/posts\/leetcode\/","datePublished":"2023-08-08T15:51:32+08:00","dateModified":"2023-08-08T15:51:32+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"都将会"},"description":"常回来看看"}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"dark"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"dark"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=left><div class=header-title><a href=/ title><img loading=lazy src=/images/avatar.jpg srcset="/images/avatar.jpg, /images/avatar.jpg 1.5x, /images/avatar.jpg 2x" sizes=auto data-title=/images/avatar.jpg data-alt=/images/avatar.jpg class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>都将会</span></a><span id=typeit-header-subtitle-desktop class="typeit header-subtitle"></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Posts</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=输入关键词搜索 id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title><img loading=lazy src=/images/avatar.jpg srcset="/images/avatar.jpg, /images/avatar.jpg 1.5x, /images/avatar.jpg 2x" sizes=auto data-title=/images/avatar.jpg data-alt=/images/avatar.jpg class=logo style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>都将会</span></a><span id=typeit-header-subtitle-mobile class="typeit header-subtitle"></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=输入关键词搜索 id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fa-solid fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></li><li class=menu-item><a class=menu-link href=/posts/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Posts</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item><a href=/ title>Home</a></li><li class=breadcrumb-item><a href=/posts/ title=Posts>Posts</a></li><li class="breadcrumb-item active" aria-current=page>LeetCode 大全</li></ol></nav><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>LeetCode 大全</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><img loading=lazy src=/images/avatar.jpg srcset="/images/avatar.jpg, /images/avatar.jpg 1.5x, /images/avatar.jpg 2x" sizes=auto data-title=都将会 data-alt=都将会 class=avatar style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;都将会</span></span>
<span class=post-category>included in <a href=/categories/practice/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> practice</a></span></div><div class=post-meta-line><span title="published on 2023-08-08 15:51:32"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-08-08>2023-08-08</time></span>&nbsp;<span title="Updated on 2023-08-08 15:51:32"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-08-08>2023-08-08</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>7092 words</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>34 minutes</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#数组>数组</a><ul><li><a href=#560和为k的子数组java>[560]和为K的子数组.java</a></li><li><a href=#304二维区域和检索---矩阵不可变java>[304]二维区域和检索 - 矩阵不可变.java</a></li><li><a href=#1094拼车java>[1094]拼车.java</a></li><li><a href=#1109航班预订统计java>[1109]航班预订统计.java</a></li><li><a href=#二分搜索模板>二分搜索模板</a></li><li><a href=#875爱吃香蕉的珂珂java>[875]爱吃香蕉的珂珂.java</a></li><li><a href=#1011在-d-天内送达包裹的能力java>[1011]在 D 天内送达包裹的能力.java</a></li><li><a href=#下一个更大元素循环搜索>下一个更大元素（循环搜索）</a></li><li><a href=#搜索二维矩阵>搜索二维矩阵</a></li><li><a href=#折线图的最少线段数>折线图的最少线段数</a></li><li><a href=#三数之和>三数之和</a></li><li><a href=#颜色分类荷兰国旗问题>颜色分类（荷兰国旗问题）</a></li><li><a href=#31下一个排列java>[31]下一个排列.java</a></li><li><a href=#200岛屿数量java>[200]岛屿数量.java</a></li><li><a href=#695岛屿的最大面积java>[695]岛屿的最大面积.java</a></li><li><a href=#79单词搜索java>[79]单词搜索.java</a></li></ul></li><li><a href=#链表>链表</a><ul><li><a href=#21合并两个有序链表java>[21]合并两个有序链表.java</a></li><li><a href=#反转链表>反转链表</a></li><li><a href=#92反转链表-iijava>[92]反转链表 II.java</a></li><li><a href=#142环形链表-iijava>[142]环形链表 II.java</a></li><li><a href=#86分隔链表java>[86]分隔链表.java</a></li><li><a href=#148排序链表java>[148]排序链表.java</a></li><li><a href=#2两数相加java>[2]两数相加.java</a></li><li><a href=#143重排链表java>[143]重排链表.java</a></li></ul></li><li><a href=#二叉树>二叉树</a><ul><li><a href=#递归框架>递归框架</a></li><li><a href=#快速排序>快速排序</a></li><li><a href=#归并排序>归并排序</a></li><li><a href=#中序遍历二叉树>中序遍历二叉树</a></li><li><a href=#105从前序与中序遍历序列构造二叉树java>[105]从前序与中序遍历序列构造二叉树.java</a></li><li><a href=#114二叉树展开为链表java>[114]二叉树展开为链表.java</a></li><li><a href=#116填充每个节点的下一个右侧节点指针java>[116]填充每个节点的下一个右侧节点指针.java</a></li><li><a href=#701二叉搜索树中的插入操作java>[701]二叉搜索树中的插入操作.java</a></li><li><a href=#450删除二叉搜索树中的节点java>[450]删除二叉搜索树中的节点.java</a></li><li><a href=#102二叉树的层序遍历java>[102]二叉树的层序遍历.java</a></li><li><a href=#752打开转盘锁java>[752]打开转盘锁.java</a></li><li><a href=#662二叉树最大宽度java>[662]二叉树最大宽度.java</a></li><li><a href=#199二叉树的右视图java>[199]二叉树的右视图.java</a></li><li><a href=#236二叉树的最近公共祖先java>[236]二叉树的最近公共祖先.java</a></li></ul></li><li><a href=#滑动窗口>滑动窗口</a><ul><li><a href=#模版>模版</a></li><li><a href=#3无重复字符的最长子串java>[3]无重复字符的最长子串.java</a></li><li><a href=#438找到字符串中所有字母异位词java>[438]找到字符串中所有字母异位词.java</a></li></ul></li><li><a href=#回溯>回溯</a><ul><li><a href=#46全排列java>[46]全排列.java</a></li><li><a href=#51n-皇后java>[51]N 皇后.java</a></li><li><a href=#22括号生成java>[22]括号生成.java</a></li><li><a href=#039-组合总和>039 组合总和</a></li><li><a href=#040-组合总和>040 组合总和Ⅱ</a></li><li><a href=#046-全排列>046 全排列</a></li><li><a href=#047-全排列>047 全排列Ⅱ</a></li></ul></li><li><a href=#动态规划>动态规划</a><ul><li><a href=#322零钱兑换java>[322]零钱兑换.java</a></li><li><a href=#53最大子序和java>[53]最大子序和.java</a></li><li><a href=#300最长递增子序列java>[300]最长递增子序列.java</a></li></ul></li><li><a href=#栈和队列>栈和队列</a><ul><li><a href=#225用队列实现栈java>[225]用队列实现栈.java</a></li><li><a href=#232用栈实现队列java>[232]用栈实现队列.java</a></li><li><a href=#496下一个更大元素-ijava>[496]下一个更大元素 I.java</a></li><li><a href=#503下一个更大元素-iijava>[503]下一个更大元素 II.java</a></li><li><a href=#1047删除字符串中的所有相邻重复项java>[1047]删除字符串中的所有相邻重复项.java</a></li></ul></li><li><a href=#其他>其他</a><ul><li><a href=#并查集union-find算法990等式方程的可满足性java>并查集（Union-Find）算法：[990]等式方程的可满足性.java</a></li><li><a href=#146lru-缓存机制java>[146]LRU 缓存机制.java</a></li><li><a href=#050-powxn>050 Pow(x,n)</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=数组>数组</h2><h3 id=560和为k的子数组java>[560]和为K的子数组.java</h3><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><h4 id=思路>思路</h4><p>采用空间换时间策略，用 map 记录前序和。</p><h4 id=代码>代码</h4><pre tabindex=0><code>class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, sum = 0;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;() {{
            put(0, 1);
        }};
        for (int num : nums) {
            sum += num;
            count += map.getOrDefault(sum - k, 0);
            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }
        return count;
    }
}</code></pre><h4 id=复杂度>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=304二维区域和检索---矩阵不可变java>[304]二维区域和检索 - 矩阵不可变.java</h3><p>给定一个二维矩阵 matrix，以下类型的多个请求： 计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。 实现 NumMatrix 类： NumMatrix(int matrix) 给定整数矩阵 matrix 进行初始化 int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角(row2, col2) 的子矩阵的元素总和。</p><h4 id=思路-1>思路</h4><p><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411113-7f651353-6ab8-49d3-8b5e-a87f18216a68.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><h4 id=代码-1>代码</h4><pre tabindex=0><code>class NumMatrix {

    // 存储左上角区域和
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        preSum = new int[m][n];
        preSum[0][0] = matrix[0][0];
        for (int i = 1; i &lt; m; i++) {
            preSum[i][0] = preSum[i - 1][0] + matrix[i][0];
        }
        for (int i = 1; i &lt; n; i++) {
            preSum[0][i] = preSum[0][i - 1] + matrix[0][i];
        }
        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                preSum[i][j] = matrix[i][j] + preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        int leftCol = (col1 == 0) ? 0 : preSum[row2][col1 - 1];
        int upRow = (row1 == 0) ? 0 : preSum[row1 - 1][col2];
        int leftUpArea = (row1 == 0 || col1 == 0) ? 0 : preSum[row1 - 1][col1 - 1];
        return preSum[row2][col2] - leftCol - upRow + leftUpArea;
    }
}</code></pre><h4 id=复杂度-1>复杂度</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n^2)</li></ul><h3 id=1094拼车java>[1094]拼车.java</h3><p>假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。由于道路的限制，车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。
这儿有一份乘客行程计划表 trips，其中 trips[i] = [num_passengers, start_location, end_location] 包含了第 i 组乘客的行程信息：</p><ol><li>必须接送的乘客数量；</li><li>乘客的上车地点；</li><li>以及乘客的下车地点。</li></ol><p>这些给出的地点位置是从你的 初始 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。 请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false）。</p><h4 id=思路-2>思路</h4><p>利用差分数组，上车加乘客数，下车减乘客数，最后遍历一次检验是否有超载情况。</p><h4 id=代码-2>代码</h4><pre tabindex=0><code>class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        // 差分数组
        int[] diff = new int[1001];
        // 统计每一站净上车人数
        for (int[] trip : trips) {
            int passengers = trip[0];
            int start = trip[1];
            int end = trip[2];
            diff[start] += passengers;
            diff[end] -= passengers;
        }
        // 排查是否有超载情况
        int cur = 0;
        for (int i : diff) {
            cur += i;
            if (cur &gt; capacity) {
                return false;
            }
        }
        return true;
    }
}</code></pre><h4 id=复杂度-2>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=1109航班预订统计java>[1109]航班预订统计.java</h3><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。
有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。 请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。</p><h4 id=思路-3>思路</h4><p>利用差分数组，根据每一条数据，在 first 处加座位数，在 last +1 处减座位数，最后遍历累加得到 answer 数组。</p><h4 id=代码-3>代码</h4><pre tabindex=0><code>class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] diff = new int[n];
        int[] answer = new int[n];
        for (int[] booking : bookings) {
            int first = booking[0];
            int last = booking[1];
            int seats = booking[2];
            diff[first - 1] += seats;
            if (last &lt; n) {
                // 实际上是 last+1-1
                // +1 是因为座位在下一站才腾出来
                // -1 是因为航班从 1 开始编号，而数组从 0 开始编号
                diff[last] -= seats;
            }
        }
        answer[0] = diff[0];
        for (int i = 1; i &lt; n; i++) {
            answer[i] = answer[i - 1] + diff[i];
        }
        return answer;
    }
}</code></pre><h4 id=复杂度-3>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=二分搜索模板>二分搜索模板</h3><pre tabindex=0><code>int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left &lt;= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] &lt; target) {
            left = mid + 1;
        } else if (nums[mid] &gt; target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}</code></pre><h4 id=寻找左边界>寻找左边界</h4><pre tabindex=0><code>int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left &lt;= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] &lt; target) {
            left = mid + 1;
        } else if (nums[mid] &gt; target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 最后要检查 left 越界的情况
    if (left &gt;= nums.length || nums[left] != target)
        return -1;
    return left;
}</code></pre><h4 id=寻找右边界>寻找右边界</h4><pre tabindex=0><code>int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left &lt;= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] &lt; target) {
            left = mid + 1;
        } else if (nums[mid] &gt; target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 最后要检查 right 越界的情况
    if (right &lt; 0 || nums[right] != target)
        return -1;
    return right;
}</code></pre><h3 id=875爱吃香蕉的珂珂java>[875]爱吃香蕉的珂珂.java</h3><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。
珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。
珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><h4 id=思路-4>思路</h4><p><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411127-fedcc0bc-d184-49af-a975-d2b1e05ecf59.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><ol><li>以速度为自变量，花费时间为应变量，构造函数，定义域在 [1,10^9]</li><li>所求为最小速度，转换为寻找左边界</li><li>花费时间过长，应当加大速度，扩大 left 边界；花费时间相等或足够小，不直接返回，而是缩小 right 边界</li><li>退出循环前，left==right && f(piles,mid)==h ， 此时位于左边界，right = mid -1 后退出循环，因此最终返回 left</li></ol><h4 id=代码-4>代码</h4><pre tabindex=0><code>class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left = 1, right = 1000000000;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2;
            if (f(piles, mid) &gt; h) {
                left = mid + 1;
            } else {
                // 别返回，锁定左侧边界
                right = mid - 1;
            }
        }
        return left;
    }

    private int f(int[] piles, int v) {
        int hours = 0;
        for (int pile : piles) {
            hours += pile / v;
            if (pile % v &gt; 0) {
                hours++;
            }
        }
        return hours;
    }
}</code></pre><h4 id=复杂度-4>复杂度</h4><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><h3 id=1011在-d-天内送达包裹的能力java>[1011]在 D 天内送达包裹的能力.java</h3><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。
传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p><h4 id=思路-5>思路</h4><ol><li>以承载量为自变量，花费天数为应变量，构造函数，承载量下限为最大的那个包裹的重量，上限为所有包裹加起来的重量。</li><li>所求为最小承载量，转换为寻找左边界</li><li>花费时间过长，应当加大承载量，扩大 left 边界；花费时间相等或足够小，不直接返回，而是缩小 right 边界</li><li>退出循环前，left==right && f(weights,mid)==days ， 此时位于左边界，right = mid -1 后退出循环，因此最终返回 left</li></ol><h4 id=代码-5>代码</h4><pre tabindex=0><code>class Solution {
    public int shipWithinDays(int[] weights, int days) {
        int left = 1, right = 1;
        for (int weight : weights) {
            if (weight &gt; left) {
                left = weight;
            }
            right += weight;
        }
        while (left &lt;= right) {
            int mid = left + (right - left) / 2;
            if (f(weights, mid) &gt; days) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }

    private int f(int[] weights, int capacity) {
        int days = 1;
        int todayCapacity = capacity;
        for (int weight : weights) {
            if (weight &gt; todayCapacity) {
                // 今天不够装了，明天一来就装这个包裹
                days++;
                todayCapacity = capacity - weight;
            } else {
                // 今天装下这个包裹没问题
                todayCapacity -= weight;
            }
        }
        return days;
    }
}</code></pre><h4 id=复杂度-5>复杂度</h4><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul><h3 id=下一个更大元素循环搜索>下一个更大元素（循环搜索）</h3><pre tabindex=0><code>class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        // 从后往前遍历
        for (int i = nums.length - 1; i &gt;= 0; i--) {
            while (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) {
                // 栈顶元素即将被 nums[i] 挡住
                stack.pop();
            }
            if (stack.isEmpty()) {
                res[i] = -1;
                // 后面找不到了，去前面找找看
                for (int j = 0; j &lt; i; j++) {
                    if (nums[j] &gt; nums[i]) {
                        res[i] = nums[j];
                        break;
                    }
                }
            } else {
                res[i] = stack.peek();
            }
            stack.push(nums[i]);
        }
        return res;
    }
}</code></pre><h3 id=搜索二维矩阵>搜索二维矩阵</h3><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。</p><pre tabindex=0><code>class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
       int m = matrix.length, n = matrix[0].length;
        int low = 0, high = m * n - 1;
        while (low &lt;= high) {
            int mid = (high - low) / 2 + low;
            int x = matrix[mid / n][mid % n];
            if (x &lt; target) {
                low = mid + 1;
            } else if (x &gt; target) {
                high = mid - 1;
            } else {
                return true;
            }
        }
        return false;
    }
}</code></pre><h3 id=折线图的最少线段数>折线图的最少线段数</h3><p>给你一个二维整数数组 stockPrices ，其中 stockPrices[i] = [dayi, pricei] 表示股票在 dayi 的价格为 pricei 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p><p><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411156-8e60abf8-6e72-4111-bbd9-c56150fa0f6a.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>请你返回要表示一个折线图所需要的 最少线段数 。</p><pre tabindex=0><code>class Solution {
    public int minimumLines(int[][] stockPrices) {
        if (stockPrices.length &lt;= 1) {
            return 0;
        }
        Arrays.sort(stockPrices, (a, b) -&gt; {
            if (a[0] == b[0]) {
                return a[1] - b[1];
            } else {
                return a[0] - b[0];
            }
        });
        int count = 1;
        String k = getK(stockPrices[1][1] - stockPrices[0][1], stockPrices[1][0] - stockPrices[0][0]);
        for (int i = 2; i &lt; stockPrices.length; i++) {
            int dy = stockPrices[i][1] - stockPrices[i - 1][1];
            int dx = stockPrices[i][0] - stockPrices[i - 1][0];
            if (dy == 0 &amp;&amp; dx == 0) {
                continue;
            }
            String tempK = getK(dy, dx);
            if (!k.equals(tempK)) {
                count++;
                k = tempK;
            }
        }
        return count;
    }

    private String getK(int dy, int dx) {
        if (dx == 0) {
            return &#34;wx&#34;;
        }
        //二者最大公约数，将两数化为最简，方便比较
        int gcd = gcd(Math.abs(dy), Math.abs(dx));
        dy /= gcd;
        dx /= gcd;
        return dy + &#34;/&#34; + dx;
    }

    /**
     * 求最大公约数
     *
     * @param a
     * @param b
     * @return
     */
    private int gcd(int a, int b) {
        if (b != 0) {
            return gcd(b, a % b);
        }
        return a;
    }
}</code></pre><h3 id=三数之和>三数之和</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><h4 id=代码双指针>代码（双指针）</h4><pre tabindex=0><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if (nums == null || nums.length &lt; 3) {
            return res;
        }
        Arrays.sort(nums);
        for (int i = 0; i &lt; nums.length - 2; i++) {
            //减枝
            if (nums[i] &gt; 0) {
                break;
            }
            //去重
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
                continue;
            }
            //后两数之和等于第一个数的相反数
            int target = -nums[i];
            int left = i + 1, right = nums.length - 1;
            while (left &lt; right) {
                if (nums[left] + nums[right] == target) {
                    res.add(Arrays.asList(nums[i], nums[left++], nums[right--]));
                    while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) {
                        left++;
                    }
                    while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) {
                        right--;
                    }
                } else if (nums[left] + nums[right] &lt; target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return res;
    }
}</code></pre><h4 id=复杂度-6>复杂度</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：$$
\begin{cases} O(logn)，不允许改变参数\ O(1)，允许改变参数 \end{cases}
$$</li></ul><h3 id=颜色分类荷兰国旗问题>颜色分类（荷兰国旗问题）</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><h4 id=代码-6>代码</h4><pre tabindex=0><code>class Solution {
    public void sortColors(int[] nums) {
        int left = 0, right = nums.length - 1;
        for (int i = 0; i &lt;= right; i++) {
            if (nums[i] == 0) {
                //i把0给了left，left只可能把0给i
                swap(nums, left++, i);
            } else if (nums[i] == 2) {
                //i把2给了right，right可能把0或1给i，所以i不能立刻自增
                swap(nums, right--, i--);
            }
        }
    }
    private void swap(int[] nums, int index1, int index2) {
        int a = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = a;
    }
}</code></pre><h4 id=复杂度-7>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=31下一个排列java>[31]下一个排列.java</h3><p>//整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 //// // 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 // //// 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 //// // 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 // 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 // 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 // //// 给你一个整数数组 nums ，找出 nums 的下一个排列。 //// 必须 原地 修改，只允许使用额外常数空间。</p><pre tabindex=0><code>class Solution {
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        int i = len - 2;
        // 从后往前找到第一个升序的数字
        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) {
            i--;
        }
        // 如果找不到，则说明是最小的排列，需要重排
        if (i &gt;= 0) {
            int j = len - 1;
            // 从后往前找到第一个比i大的数字
            while (nums[i] &gt;= nums[j]) {
                j--;
            }
            // 交换i和j
            swap(nums, i, j);
        }
        // 反转后面的数字:从降序变成升序
        reverse(nums, i + 1);
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void reverse(int[] nums, int start) {
        int len = nums.length;
        int i = start, j = len - 1;
        while (i &lt; j) {
            swap(nums, i++, j--);
        }
    }
}</code></pre><h3 id=200岛屿数量java>[200]岛屿数量.java</h3><p>给你一个由 &lsquo;1&rsquo;（陆地）和 &lsquo;0&rsquo;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。</p><pre tabindex=0><code>class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for (int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[i].length; j++) {
                if (grid[i][j] == &#39;1&#39;) {
                    count++;
                    callBFS(grid, i, j);
                }
            }
        }
        return count;
    }
    private void callBFS(char[][] grid, int i, int j) {
        if (i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[i].length || grid[i][j] == &#39;0&#39;) {
            return;
        }
        grid[i][j] = &#39;0&#39;;
        callBFS(grid, i + 1, j);
        callBFS(grid, i - 1, j);
        callBFS(grid, i, j + 1);
        callBFS(grid, i, j - 1);
    }
}</code></pre><h3 id=695岛屿的最大面积java>[695]岛屿的最大面积.java</h3><p>//给你一个大小为 m x n 的二进制矩阵 grid 。 //// 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都//被 0（代表水）包围着。 //// 岛屿的面积是岛上值为 1 的单元格的数目。 //// 计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><pre tabindex=0><code>class Solution {
    boolean visited[][];

    public int maxAreaOfIsland(int[][] grid) {
        int res = 0;
        int rows = grid.length;
        int cols = grid[0].length;
        visited = new boolean[rows][cols];
        for (int i = 0; i &lt; rows; i++) {
            for (int j = 0; j &lt; cols; j++) {
                res = Math.max(res, area(i, j, grid));
            }
        }
        return res;
    }

    public int area(int row, int column, int[][] grid) {
        if (row &lt; 0 || row &gt;= grid.length || column &lt; 0 || column &gt;= grid[row].length || visited[row][column] || grid[row][column] == 0) {
            return 0;
        }
        visited[row][column] = true;
        return 1 + area(row + 1, column, grid) + area(row - 1, column, grid) + area(row, column + 1, grid) + area(row, column - 1, grid);
    }
}</code></pre><h3 id=79单词搜索java>[79]单词搜索.java</h3><p>//给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 //// 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><pre tabindex=0><code>class Solution {
    boolean[][] visited;

    public boolean exist(char[][] board, String word) {
        final int rows = board.length;
        final int cols = board[0].length;
        visited = new boolean[rows][cols];
        for (int i = 0; i &lt; rows; i++) {
            for (int j = 0; j &lt; cols; j++) {
                if (dfs(board, word, 0, i, j)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(char[][] board, String word, int index, int i, int j) {
        if (index == word.length()) {
            return true;
        }
        if (i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {
            return false;
        }
        visited[i][j] = true;
        boolean res = dfs(board, word, index + 1, i + 1, j) ||
                dfs(board, word, index + 1, i - 1, j) ||
                dfs(board, word, index + 1, i, j + 1) ||
                dfs(board, word, index + 1, i, j - 1);
        visited[i][j] = false;
        return res;
    }
}</code></pre><h2 id=链表>链表</h2><h3 id=21合并两个有序链表java>[21]合并两个有序链表.java</h3><pre tabindex=0><code>class Solution {
    // 非递归
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 伪头结点
        ListNode dummyHead = new ListNode(-1);
        ListNode cur = dummyHead;
        while (l1 != null &amp;&amp; l2 != null) {
            if (l1.val &lt; l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        // 剩余部分
        cur.next = l1 == null ? l2 : l1;
        return dummyHead.next;
    }
}</code></pre><h3 id=反转链表>反转链表</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><h4 id=代码-7>代码</h4><pre tabindex=0><code>class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null, cur = head, next;
        while (cur != null) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        //cur==null 退出循环，pre此时指向之前的尾节点，现在的头节点。
        return pre;
    }
}</code></pre><h4 id=复杂度-8>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=92反转链表-iijava>[92]反转链表 II.java</h3><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-37817cc4-f93a-4f64-b78a-adb86f244a97.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><pre tabindex=0><code>class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        ListNode dummyNode = new ListNode(-1, head);
        ListNode pre = dummyNode;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        // 建议写在 for 循环里，语义清晰
        for (int i = 0; i &lt; left - 1; i++) {
            pre = pre.next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode rightNode = pre;
        for (int i = 0; i &lt; right - left + 1; i++) {
            rightNode = rightNode.next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        ListNode leftNode = pre.next;
        ListNode curr = rightNode.next;

        // 注意：切断链接
        pre.next = null;
        rightNode.next = null;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseLinkedList(leftNode);

        // 第 5 步：接回到原来的链表中
        pre.next = rightNode;
        leftNode.next = curr;
        return dummyNode.next;
    }

    private void reverseLinkedList(ListNode head) {
        // 也可以使用递归反转一个链表
        ListNode pre = null;
        ListNode cur = head;

        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
    }
}</code></pre><h3 id=142环形链表-iijava>[142]环形链表 II.java</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。</p><h4 id=思路-6>思路</h4><p><img loading=lazy src=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png srcset="https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png 1.5x, https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png 2x" sizes=auto data-title=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png data-alt=https://publicpictures.oss-cn-hangzhou.aliyuncs.com/img/1678170411124-b781a2aa-205c-4c14-bf70-b19a147f3163.png style="background:url(/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></p><p>如图所示，先分析第一次相遇：
slow 走过距离：a+b
fast 走过距离：a+b+n(b+c)
又因为 fast 速度是 slow 的 2 倍，得：2(a+b) = a+b+n(b+c)
化简得：a=(n-1)(b+c)+c
这时，让 fast 指针回到起点，slow 指针留在原地，它们同时以相同速度运动 c 的距离，慢指针到达交点处，快指针距离交点距离是环长的整数倍，由于我们不知道 c 的大小，只能让快慢指针继续保持相同速度向前走，直到第二次相遇，相遇点必是交点。</p><h4 id=代码-8>代码</h4><pre tabindex=0><code>public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                break;
            }
        }
        //无环
        if (fast == null || fast.next == null) {
            return null;
        }
        fast = head;
        while (fast != slow) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}</code></pre><h4 id=复杂度-9>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=86分隔链表java>[86]分隔链表.java</h3><p>//给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 //// 你应当 保留 两个分区中每个节点的初始相对位置。 //// //// 示例 1： //// //输入：head = [1,4,3,2,5,2], x = 3//输出：[1,2,2,4,3,5]</p><pre tabindex=0><code>class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode left = new ListNode(0);
        ListNode right = new ListNode(0);
        ListNode l = left;
        ListNode r = right;
        while (head != null) {
            if (head.val &lt; x) {
                l.next = head;
                l = l.next;
            } else {
                r.next = head;
                r = r.next;
            }
            head = head.next;
        }
        l.next = right.next;
        r.next = null;
        return left.next;
    }
}</code></pre><h3 id=148排序链表java>[148]排序链表.java</h3><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><pre tabindex=0><code>class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode slow = head, fast = head.next;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode right = sortList(slow.next);
        slow.next = null;
        ListNode left = sortList(head);
        return merge(left, right);
    }

    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        while (l1 != null &amp;&amp; l2 != null) {
            if (l1.val &lt; l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        cur.next = l1 == null ? l2 : l1;
        return dummy.next;
    }
}</code></pre><h3 id=2两数相加java>[2]两数相加.java</h3><p>//给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 //// 请你将两个数相加，并以相同形式返回一个表示和的链表。 //// 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 //// //// 示例 1： //// //输入：l1 = [2,4,3], l2 = [5,6,4]//输出：[7,0,8]//解释：342 + 465 = 807.</p><pre tabindex=0><code>class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int x = l1 == null ? 0 : l1.val;
            int y = l2 == null ? 0 : l2.val;
            int sum = x + y + carry;
            carry = sum / 10;
            cur.next = new ListNode(sum % 10);
            cur = cur.next;
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        if (carry &gt; 0) {
            cur.next = new ListNode(carry);
        }
        return dummyHead.next;
    }
}</code></pre><h3 id=143重排链表java>[143]重排链表.java</h3><p>//给定一个单链表 L 的头节点 head ，单链表 L 表示为： //// //L0 → L1 → … → Ln - 1 → Ln// //// 请将其重新排列后变为： //// //L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … //// 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><pre tabindex=0><code>class Solution {
    public void reorderList(ListNode head) {
        if (head == null || head.next == null) {
            return;
        }
        ListNode l1 = head;
        ListNode slow = head, fast = head, prev = null;
        while (fast != null &amp;&amp; fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        prev.next = null;
        ListNode l2 = slow;
        l2 = reverse(l2);
        l1 = merge(l1, l2);
    }

    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        ListNode curNode = head;
        while (curNode != null) {
            ListNode nextNode = curNode.next;
            curNode.next = prev;
            prev = curNode;
            curNode = nextNode;
        }
        return prev;
    }

    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(-1);
        ListNode curNode = dummyHead;
        while (l1 != null &amp;&amp; l2 != null) {
            curNode.next = l1;
            curNode = curNode.next;
            l1 = l1.next;
            curNode.next = l2;
            curNode = curNode.next;
            l2 = l2.next;
        }
        curNode.next = l1 == null ? l2 : l1;
        return dummyHead.next;
    }

}</code></pre><h2 id=二叉树>二叉树</h2><p>快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历。</p><h3 id=递归框架>递归框架</h3><pre tabindex=0><code>/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}</code></pre><h3 id=快速排序>快速排序</h3><pre tabindex=0><code>void sort(int[] nums, int lo, int hi) {
    /****** 前序遍历位置 ******/
    // 通过交换元素构建分界点 p
    int p = partition(nums, lo, hi);
    /************************/

    sort(nums, lo, p - 1);
    sort(nums, p + 1, hi);
}</code></pre><h3 id=归并排序>归并排序</h3><pre tabindex=0><code>void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    sort(nums, lo, mid);
    sort(nums, mid + 1, hi);

    /****** 后序遍历位置 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
    /************************/
}</code></pre><p>可以说，只要涉及递归，都可以抽象成二叉树的问题。</p><h3 id=中序遍历二叉树>中序遍历二叉树</h3><div class=highlight id=id-30><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>inorderTraversal</span><span style=color:#f92672>(</span>TreeNode root<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> res <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        Deque<span style=color:#f92672>&lt;</span>TreeNode<span style=color:#f92672>&gt;</span> stack <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>TreeNode cur <span style=color:#f92672>=</span> root<span style=color:#f92672>;</span> cur <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>stack<span style=color:#f92672>.</span><span style=color:#a6e22e>isEmpty</span><span style=color:#f92672>();</span> cur <span style=color:#f92672>=</span> cur<span style=color:#f92672>.</span><span style=color:#a6e22e>right</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 一直下到最左
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>cur <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                stack<span style=color:#f92672>.</span><span style=color:#a6e22e>push</span><span style=color:#f92672>(</span>cur<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                cur <span style=color:#f92672>=</span> cur<span style=color:#f92672>.</span><span style=color:#a6e22e>left</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            cur <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span><span style=color:#a6e22e>pop</span><span style=color:#f92672>();</span><span style=color:#75715e>// 每次出栈的就是中序遍历顺序的节点，然后在以下进行对应操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            res<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>cur<span style=color:#f92672>.</span><span style=color:#a6e22e>val</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 最后向右一步
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><h3 id=105从前序与中序遍历序列构造二叉树java>[105]从前序与中序遍历序列构造二叉树.java</h3><div class=highlight id=id-31><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> TreeNode <span style=color:#a6e22e>buildTree</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> preorder<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> inorder<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> Integer<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> inorder<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>inorder<span style=color:#f92672>[</span>i<span style=color:#f92672>],</span> i<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> buildTreeHelper<span style=color:#f92672>(</span>preorder<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> preorder<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>,</span> inorder<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> inorder<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>,</span> map<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>* 指针左闭右开
</span></span></span><span style=display:flex><span><span style=color:#75715e>*
</span></span></span><span style=display:flex><span><span style=color:#75715e>* @param preorder
</span></span></span><span style=display:flex><span><span style=color:#75715e>* @param p_start
</span></span></span><span style=display:flex><span><span style=color:#75715e>* @param p_end
</span></span></span><span style=display:flex><span><span style=color:#75715e>* @param inorder
</span></span></span><span style=display:flex><span><span style=color:#75715e>* @param i_start
</span></span></span><span style=display:flex><span><span style=color:#75715e>* @param i_end
</span></span></span><span style=display:flex><span><span style=color:#75715e>* @param map
</span></span></span><span style=display:flex><span><span style=color:#75715e>* @return
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TreeNode <span style=color:#a6e22e>buildTreeHelper</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> preorder<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> p_start<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> p_end<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> inorder<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> i_start<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> i_end<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                                     HashMap<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> Integer<span style=color:#f92672>&gt;</span> map<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>p_start <span style=color:#f92672>==</span> p_end<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> root_val <span style=color:#f92672>=</span> preorder<span style=color:#f92672>[</span>p_start<span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>        TreeNode root <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TreeNode<span style=color:#f92672>(</span>root_val<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> i_root_index <span style=color:#f92672>=</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>root_val<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> leftNum <span style=color:#f92672>=</span> i_root_index <span style=color:#f92672>-</span> i_start<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// preorder 分为 [p_start + 1,p_start + leftNum + 1) 和 [p_start + leftNum + 1, p_end]，前序根结点在左边
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// inorder 分为 [i_start,i_root_index) 和 [i_root_index + 1,i_end)，少一个根结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        root<span style=color:#f92672>.</span><span style=color:#a6e22e>left</span> <span style=color:#f92672>=</span> buildTreeHelper<span style=color:#f92672>(</span>preorder<span style=color:#f92672>,</span> p_start <span style=color:#f92672>+</span> 1<span style=color:#f92672>,</span> p_start <span style=color:#f92672>+</span> leftNum <span style=color:#f92672>+</span> 1<span style=color:#f92672>,</span> inorder<span style=color:#f92672>,</span> i_start<span style=color:#f92672>,</span> i_root_index<span style=color:#f92672>,</span> map<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        root<span style=color:#f92672>.</span><span style=color:#a6e22e>right</span> <span style=color:#f92672>=</span> buildTreeHelper<span style=color:#f92672>(</span>preorder<span style=color:#f92672>,</span> p_start <span style=color:#f92672>+</span> 1 <span style=color:#f92672>+</span> leftNum<span style=color:#f92672>,</span> p_end<span style=color:#f92672>,</span> inorder<span style=color:#f92672>,</span> i_root_index <span style=color:#f92672>+</span> 1<span style=color:#f92672>,</span> i_end<span style=color:#f92672>,</span> map<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span></span></span></code></pre></div><h3 id=114二叉树展开为链表java>[114]二叉树展开为链表.java</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><h4 id=思路-7>思路</h4><ol><li>把每个节点的左子树插入到该节点与右子树之间；</li><li>应用后序递归框架（左、右、根）。</li></ol><h4 id=代码-9>代码</h4><pre tabindex=0><code>class Solution {
    public void flatten(TreeNode root) {
        // 1. 叶子节点
        if (root == null) return;

        // 2. 递归 flatten
        TreeNode left = root.left;
        TreeNode right = root.right;
        flatten(left);
        flatten(right);

        // 3. 拼左
        root.left = null;
        root.right = left;

        // 4. 拼右
        TreeNode p = root;
        while (p.right != null) {
            p = p.right;
        }
        p.right = right;
    }
}</code></pre><h4 id=复杂度-10>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=116填充每个节点的下一个右侧节点指针java>[116]填充每个节点的下一个右侧节点指针.java</h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。</p><h4 id=思路-8>思路</h4><ol><li>把每个节点的左子树指向右子树；</li><li>值得注意的是，左子树的右子树也要指向右子树的左子树；</li><li>应用前序递归框架（根、左、右）。</li></ol><h4 id=代码-10>代码</h4><pre tabindex=0><code>class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return null;
        }
        connect(root.left, root.right);
        return root;
    }

    private void connect(Node left, Node right) {
        if (left == null || right == null) {
            return;
        }
        left.next = right;
        // 四个点，三个指向
        connect(left.left, left.right);
        connect(left.right, right.left);
        connect(right.left, right.right);
    }
}</code></pre><h4 id=复杂度-11>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=701二叉搜索树中的插入操作java>[701]二叉搜索树中的插入操作.java</h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同</p><h4 id=思路-9>思路</h4><p>这题的关键在于重置 <strong>搜索路径</strong> 上节点的左或右子树，如果不为空，则递归；如果为空，直接 new 一个新节点，这个节点不需要做任何处理，它是会被上一次递归所指向的。</p><h4 id=代码-11>代码</h4><pre tabindex=0><code>class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        if (val &gt; root.val) {
            root.right = insertIntoBST(root.right, val);
        } else {
            root.left = insertIntoBST(root.left, val);
        }
        return root;
    }
}</code></pre><h4 id=复杂度-12>复杂度</h4><ul><li>时间复杂度：平均情况 O(logn)，最坏情况 O(n)</li><li>空间复杂度：平均情况 O(logn)，最坏情况 O(n)</li></ul><h3 id=450删除二叉搜索树中的节点java>[450]删除二叉搜索树中的节点.java</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><h4 id=思路-10>思路</h4><ol><li>首先，查找和删除这两步不能分开，因为删除还需要用到删除节点的上一个节点。</li><li>找到元素后，如果删除节点左右子树有空着的，只需要把另一棵子树移到当前位置即可，直接返回，这个节点不需要做任何处理，它是会被上一次递归所指向的。</li><li>最复杂的是要删除的节点左右子树都不为空的情况，可以用一个小技巧：找到要删除节点的下一个更大节点，它的位置在其右子树的最左叶子节点，设为 p 节点，用 p 节点的值覆盖要删除的节点的值，这时 p 节点的值出现了 2 次，然后转而去右子树删除 p 节点的值。</li></ol><h4 id=代码-12>代码</h4><pre tabindex=0><code>class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) {
            return null;
        } else if (root.val == key) {
            if (root.left == null || root.right == null) {
                return root.left == null ? root.right : root.left;
            } else {
                // 把右子树最左结点移到当前位置
                TreeNode p = root.right;
                while (p.left != null) {
                    p = p.left;
                }
                // 把要删除的值先覆盖，此时这个值出现 2 次， 去右子树删除多余的节点
                root.val = p.val;
                root.right = deleteNode(root.right, p.val);
            }
        } else if (root.val &lt; key) {
            root.right = deleteNode(root.right, key);
        } else if (root.val &gt; key) {
            root.left = deleteNode(root.left, key);
        }
        return root;
    }
}</code></pre><h4 id=复杂度-13>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=102二叉树的层序遍历java>[102]二叉树的层序遍历.java</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><h4 id=思路-11>思路</h4><ol><li>构建一个队列，初始化时将根结点入队；</li><li>每个节点出队时，将它的子节点按先左后右的顺序入队；</li><li>只要队列非空就重复以上步骤。</li></ol><h4 id=代码-13>代码</h4><pre tabindex=0><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();
        if (root == null) {
            return res;
        }
        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); // 核心数据结构
        q.offer(root); // 将起点加入队列
        while (!q.isEmpty()) {
            int size = q.size();
            List&lt;Integer&gt; row = new LinkedList&lt;&gt;();
            for (int i = 0; i &lt; size; i++) {
                TreeNode cur = q.poll();
                row.add(cur.val);
                if (cur.left != null) {
                    q.offer(cur.left);
                }
                if (cur.right != null) {
                    q.offer(cur.right);
                }
            }
            res.add(row);
        }
        return res;
    }
}</code></pre><h4 id=复杂度-14>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=752打开转盘锁java>[752]打开转盘锁.java</h3><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &lsquo;0&rsquo;, &lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;, &lsquo;5&rsquo;, &lsquo;6&rsquo;, &lsquo;7&rsquo;, &lsquo;8&rsquo;, &lsquo;9&rsquo;。每个拨轮可以自由旋转：例如把 &lsquo;9&rsquo; 变为 &lsquo;0&rsquo;，&lsquo;0&rsquo; 变为 &lsquo;9&rsquo; 。每次旋转都只能旋转一个拨轮的一位数字。
锁的初始数字为 &lsquo;0000&rsquo; ，一个代表四个拨轮的数字的字符串。
列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p><h4 id=思路-12>思路</h4><ol><li>运用 BFS 框架，构建一个队列，每当一个字符串出队，就将改变 4 个密码位的 8 种情况入队，每判断一层，计数自增，当出队值等于目标值时返回计数，否则最终返回 -1；</li><li>针对字符串中的某一位操作，可以抽一个方法出来；</li><li>题目还给了一组死亡数字，当出队字符串包含其中时，就跳过，说明走到了死胡同；</li><li>当出队的字符串不是最终目标时，就把它加入死亡数字，这样可以防止重复访问，走入死循环。</li></ol><h4 id=代码-14>代码</h4><pre tabindex=0><code>class Solution {
    public int openLock(String[] deadends, String target) {
        Queue&lt;String&gt; q = new LinkedList&lt;&gt;();
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        for (String deadend : deadends) {
            set.add(deadend);
        }
        q.offer(&#34;0000&#34;);
        int count = 0;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i &lt; size; i++) {
                String cur = q.poll();
                if (cur.equals(target)) {
                    return count;
                }
                if (set.contains(cur)) {
                    continue;
                }
                set.add(cur);
                for (int j = 0; j &lt; 4; j++) {
                    q.offer(operateOne(cur, j, 1));
                    q.offer(operateOne(cur, j, -1));
                }
            }
            count++;
        }
        return -1;
    }

    /**
     * 改变字符串中的某一位
     *
     * @param s      字符串
     * @param index  哪一位
     * @param change 改变多少 （对于转盘锁只能传入 +1 或 -1）
     * @return
     */
    private String operateOne(String s, int index, int change) {
        char[] ch = s.toCharArray();
        if (ch[index] == &#39;9&#39; &amp;&amp; change == 1) {
            ch[index] = &#39;0&#39;;
        } else if (ch[index] == &#39;0&#39; &amp;&amp; change == -1) {
            ch[index] = &#39;9&#39;;
        } else {
            ch[index] += change;
        }
        return new String(ch);
    }
}</code></pre><h4 id=复杂度-15>复杂度</h4><p>因为数字的进制、转盘的位数都是常数，</p><ul><li>时间复杂度：O(deadends.length)</li><li>空间复杂度：O(deadends.length)</li></ul><h3 id=662二叉树最大宽度java>[662]二叉树最大宽度.java</h3><p>//给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。 //// 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。 //// 示例 1: //// //输入: //// 1// / // 3 2// / \ // 5 3 9 ////输出: 4//解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。</p><pre tabindex=0><code>class Solution {
    int maxWidth;
    Map&lt;Integer, Integer&gt; leftmostPositions;

    public int widthOfBinaryTree(TreeNode root) {
        maxWidth = 0;
        leftmostPositions = new HashMap&lt;&gt;();
        getWidth(root, 0, 0);
        return maxWidth;
    }

    private void getWidth(TreeNode node, int depth, int position) {
        if (node == null) return;
        // 不存在该层，则初始化
        leftmostPositions.computeIfAbsent(depth, key -&gt; position);
        maxWidth = Math.max(maxWidth, position - leftmostPositions.get(depth) + 1);
        // 当前节点的左右边界
        getWidth(node.left, depth + 1, position * 2);
        getWidth(node.right, depth + 1, position * 2 + 1);
    }
}</code></pre><h3 id=199二叉树的右视图java>[199]二叉树的右视图.java</h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><pre tabindex=0><code>class Solution {
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();
        if (root == null) return result;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i &lt; size; i++) {
                TreeNode currentNode = queue.poll();
                if (i == 0) result.add(currentNode.val);
              // 入队：先右后左；否则就取 i == size -1 也可以
                if (currentNode.right != null) queue.offer(currentNode.right);
                if (currentNode.left != null) queue.offer(currentNode.left);
            }
        }
        return result;
    }
}</code></pre><h3 id=236二叉树的最近公共祖先java>[236]二叉树的最近公共祖先.java</h3><div class=highlight id=id-40><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> TreeNode <span style=color:#a6e22e>lowestCommonAncestor</span><span style=color:#f92672>(</span>TreeNode root<span style=color:#f92672>,</span> TreeNode p<span style=color:#f92672>,</span> TreeNode q<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>root <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> root <span style=color:#f92672>==</span> p <span style=color:#f92672>||</span> root <span style=color:#f92672>==</span> q<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> root<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        TreeNode left <span style=color:#f92672>=</span> lowestCommonAncestor<span style=color:#f92672>(</span>root<span style=color:#f92672>.</span><span style=color:#a6e22e>left</span><span style=color:#f92672>,</span> p<span style=color:#f92672>,</span> q<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        TreeNode right <span style=color:#f92672>=</span> lowestCommonAncestor<span style=color:#f92672>(</span>root<span style=color:#f92672>.</span><span style=color:#a6e22e>right</span><span style=color:#f92672>,</span> p<span style=color:#f92672>,</span> q<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>left <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> right<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>right <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> left<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><h2 id=滑动窗口>滑动窗口</h2><h3 id=模版>模版</h3><pre tabindex=0><code>/* 滑动窗口算法框架 */
    void slidingWindow(String s, String t) {
        Map&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();
        Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; t.length(); i++) {
            char c = t.charAt(i);
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int left = 0, right = 0;
        int valid = 0;
        while (right &lt; s.length()) {
            // c 是将移入窗口的字符
            char c = s.charAt(right++);
            // todo 进行窗口内数据的一系列更新

            // todo 判断左侧窗口是否要收缩
            while (window need shrink) {
                // d 是将移出窗口的字符
                char d = s.charAt(left++);
                // todo 进行窗口内数据的一系列更新
            }
        }
    }</code></pre><ul><li>right：寻找可行解</li><li>left：试探最优解</li></ul><h3 id=3无重复字符的最长子串java>[3]无重复字符的最长子串.java</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><h4 id=思路-13>思路</h4><ul><li>right：寻找可行解：只要无重复字符就前进，一旦出现重复字符就停止，记录坐标</li><li>left：试探最优解：出现重复字符时前进，直到重复字符消失</li></ul><h4 id=代码-15>代码</h4><div class=highlight id=id-42><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lengthOfLongestSubstring</span><span style=color:#f92672>(</span>String s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>()</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>Character<span style=color:#f92672>,</span> Integer<span style=color:#f92672>&gt;</span> map <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> 0<span style=color:#f92672>,</span> right <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>right <span style=color:#f92672>&lt;</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>())</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// c 是将移入窗口的字符，右移窗口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>charAt</span><span style=color:#f92672>(</span>right<span style=color:#f92672>++);</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 进行窗口内数据的一系列更新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>c<span style=color:#f92672>,</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>getOrDefault</span><span style=color:#f92672>(</span>c<span style=color:#f92672>,</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> 1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>//  判断左侧窗口是否要收缩
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>c<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// d 是将移出窗口的字符，左移窗口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>char</span> d <span style=color:#f92672>=</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>charAt</span><span style=color:#f92672>(</span>left<span style=color:#f92672>++);</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 进行窗口内数据的一系列更新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>d<span style=color:#f92672>,</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>d<span style=color:#f92672>)</span> <span style=color:#f92672>-</span> 1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>max</span><span style=color:#f92672>(</span>res<span style=color:#f92672>,</span> right <span style=color:#f92672>-</span> left<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><h4 id=复杂度-16>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=438找到字符串中所有字母异位词java>[438]找到字符串中所有字母异位词.java</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
异位词 指字母相同，但排列不同的字符串。</p><h4 id=思路-14>思路</h4><p>当窗口大小等于 p 的长度时，左右指针同时前进，寻找可行解。</p><h4 id=代码-16>代码</h4><pre tabindex=0><code>class Solution {
    public List&lt;Integer&gt; findAnagrams(String s, String p) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        Map&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();
        Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; p.length(); i++) {
            char c = p.charAt(i);
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int left = 0, right = 0;
        int valid = 0;
        while (right &lt; s.length()) {
            // c 是将移入窗口的字符
            char c = s.charAt(right++);
            // 进行窗口内数据的一系列更新
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (window.get(c).equals(need.get(c))) {
                    valid++;
                }
            }

            // 判断左侧窗口是否要收缩
            if (right - left == p.length()) {
                if (valid == need.size()) {
                    res.add(left);
                }
                // d 是将移出窗口的字符
                char d = s.charAt(left++);
                // 进行窗口内数据的一系列更新
                if (need.containsKey(d)) {
                    if (window.get(d).equals(need.get(d))) {
                        valid--;
                    }
                    window.put(d, window.get(d) - 1);
                }
            }
        }
        return res;
    }
}</code></pre><h4 id=复杂度-17>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id=回溯>回溯</h2><h3 id=46全排列java>[46]全排列.java</h3><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><h4 id=思路-15>思路</h4><ol><li>定义结果集为全局变量；</li><li>核心是写出回溯函数，明确增添结果、退出递归的时机，向每一种可能的情况迈出一小步，进入下一次回溯，在最后还要归位；</li><li>正确的结果集：路径长度达到数字长度；</li><li>筛选条件：数字在路径中没有出现过；</li><li>对算法进行适当的剪枝，提高时间效率。</li></ol><h4 id=代码-17>代码</h4><pre tabindex=0><code>class Solution {
    // 结果集
    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
				// add、remove 不会影响new ArrayList 的浅拷贝
        backTrack(nums, new LinkedList&lt;&gt;());
        return res;
    }

    private void backTrack(int[] nums, LinkedList&lt;Integer&gt; path) {
        // 增添结果、退出递归
        if (path.size() == nums.length) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }
        for (int i = 0; i &lt; nums.length; i++) {
            // 筛选
            if (path.contains(nums[i])) {
                continue;
            }
            // 试探步
            path.addLast(nums[i]);
            // 回溯
            backTrack(nums, path);
            // 归位
            path.removeLast();
        }
    }
}</code></pre><h4 id=复杂度-18>复杂度</h4><ul><li>时间复杂度：O(n*n!)</li><li>空间复杂度：O(n)</li></ul><h3 id=51n-皇后java>[51]N 皇后.java</h3><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &lsquo;Q&rsquo; 和 &lsquo;.&rsquo; 分别代表了皇后和空位。</p><h4 id=思路-16>思路</h4><ol><li>定义结果集为全局变量；</li><li>核心是写出回溯函数，明确增添结果、退出递归的时机，向每一种通过筛选的情况迈出一小步，进入下一次回溯，在最后还要归位；</li><li>正确的结果集：第 8 行皇后符合要求；</li><li>筛选条件：任意两皇后不在同一行、同一列或同一斜线；</li><li>对算法进行适当的剪枝，提高时间效率。</li></ol><h4 id=代码-18>代码</h4><pre tabindex=0><code>class Solution {
    // 结果集
    private List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();

    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {
        // 初始化棋盘
        char[][] board = new char[n][n];
        for (char[] line : board) {
            Arrays.fill(line, &#39;.&#39;);
        }
        backTrack(board, 0);
        return res;
    }

    private void backTrack(char[][] board, int row) {
        // 增添结果、退出递归
        if (row == board.length) {
            List&lt;String&gt; list = new ArrayList&lt;&gt;();
            for (char[] c : board) {
                list.add(String.copyValueOf(c));
            }
            res.add(list);
            return;
        }
        for (int col = 0; col &lt; board[row].length; col++) {
            // 筛选
            if (!isValid(board, row, col)) {
                continue;
            }
            // 试探步
            board[row][col] = &#39;Q&#39;;
            // 回溯
            backTrack(board, row + 1);
            // 归位
            board[row][col] = &#39;.&#39;;
        }
    }

    private boolean isValid(char[][] board, int row, int col) {
        int n = board.length;
        // 检查列是否有皇后冲突
        for (int i = 0; i &lt; n; i++) {
            if (board[i][col] == &#39;Q&#39;) {
                return false;
            }
        }

        // 检查右上方是否有皇后冲突
        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {
            if (board[i][j] == &#39;Q&#39;) {
                return false;
            }
        }

        // 检查左上方是否有皇后冲突
        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {
            if (board[i][j] == &#39;Q&#39;) {
                return false;
            }
        }
        return true;
    }
}</code></pre><h4 id=复杂度-19>复杂度</h4><ul><li>时间复杂度：O(n!)</li><li>空间复杂度：O(n)</li></ul><h3 id=22括号生成java>[22]括号生成.java</h3><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
有效括号组合需满足：左括号必须以正确的顺序闭合。</p><h4 id=思路-17>思路</h4><ol><li>以左右括号剩余数为筛选、判断的标准；</li><li>正确的结果集：左右括号剩余数都为 0；</li><li>筛选条件：左右括号剩余数都为非负数，且右括号剩余数不小于左括号剩余数；</li></ol><h4 id=代码-19>代码</h4><pre tabindex=0><code>class Solution {
    // 结果集
    List&lt;String&gt; res = new LinkedList&lt;&gt;();

    public List&lt;String&gt; generateParenthesis(int n) {
        String curStr = &#34;&#34;;
        // 结果演进的起点是空字符串，左右各有n个括号
        backtrack(curStr, n, n);
        return res;
    }

    /**
     * 回溯法
     *
     * @param str   路径
     * @param left  左括号剩余数
     * @param right 右括号剩余数
     */
    private void backtrack(String str, int left, int right) {
        //边界条件 base case
        if (left == 0 &amp;&amp; right == 0) {
            res.add(str);
            return;
        }
        //减枝：左括号数必须大于等于右括号
        if (left &lt; 0 || right &lt; 0 || left &gt; right) {
            return;
        }
        if (left &gt; 0) {
            backtrack(str + &#34;(&#34;, left - 1, right);
        }
        if (right &gt; 0) {
            backtrack(str + &#34;)&#34;, left, right - 1);
        }
    }
}</code></pre><h4 id=复杂度-20>复杂度</h4><ul><li>时间复杂度： O(C_{2n}^n)</li><li>空间复杂度：O(1)</li></ul><h3 id=039-组合总和>039 组合总和</h3><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。</p><h4 id=代码-20>代码</h4><pre tabindex=0><code>class Solution {
    // 结果集
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        if (candidates == null || candidates.length == 0) {
            return res;
        }
        Arrays.sort(candidates);
        backTrack(new ArrayList&lt;&gt;(), 0, 0, candidates, target);
        return res;
    }

    private void backTrack(List&lt;Integer&gt; path, int sum, int idx, int[] candidates, int target) {
        // base case
        if (sum == target) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }
        for (int i = idx; i &lt; candidates.length; i++) {
            // 减枝
            if (sum + candidates[i] &gt; target) {
                break;
            }
            path.add(candidates[i]);
            backTrack(path, sum + candidates[i], i, candidates, target);
            path.remove(path.size() - 1);
        }
    }
}</code></pre><h4 id=复杂度-21>复杂度</h4><ul><li>时间复杂度：O(n*2^n)实际运行情况远远小于这个上界可表示为 O(S)，其中 S 为所有可行解的长度之和</li><li>空间复杂度：O(target)</li></ul><h3 id=040-组合总和>040 组合总和Ⅱ</h3><p>在 039 组合总和 的基础上，每个数字在每个组合中只能使用一次</p><h4 id=代码-21>代码</h4><pre tabindex=0><code>class Solution {
    // 结果集
    Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
        if (candidates == null || candidates.length == 0) {
            return new ArrayList&lt;&gt;(res);
        }
        Arrays.sort(candidates);
        backTrack(new ArrayList&lt;&gt;(), 0, 0, candidates, target);
        // 返回值类型需要 Set 转 List
        return new ArrayList&lt;&gt;(res);
    }

    private void backTrack(List&lt;Integer&gt; path, int sum, int idx, int[] candidates, int target) {
        // base case
        if (sum == target) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }
        for (int i = idx; i &lt; candidates.length; i++) {
            // 减枝
            if (sum + candidates[i] &gt; target) {
                break;
            }
            path.add(candidates[i]);
            //回溯时用过的数字不能再用
            backTrack(path, sum + candidates[i], i + 1, candidates, target);
            path.remove(path.size() - 1);
        }
    }
}</code></pre><h4 id=复杂度-22>复杂度</h4><ul><li>时间复杂度：O(n*2^n)实际运行情况远远小于这个上界可表示为 O(S)，其中 S 为所有可行解的长度之和</li><li>空间复杂度：O(target)</li></ul><h3 id=046-全排列>046 全排列</h3><p>给定一个不含重复数字的数组 nums ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><h4 id=代码-22>代码</h4><pre tabindex=0><code>class Solution {
    // 结果集
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        backTrack(nums, new LinkedList&lt;&gt;());
        return res;
    }

    private void backTrack(int[] nums, LinkedList&lt;Integer&gt; path) {
        // 减枝
        if (path.size() == nums.length) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }
        for (int i = 0; i &lt; nums.length; i++) {
            // 筛选
            if (path.contains(nums[i])) {
                continue;
            }
            path.addLast(nums[i]);
            backTrack(nums, path);
            path.removeLast();
        }
    }
}</code></pre><h4 id=复杂度-23>复杂度</h4><ul><li>时间复杂度：O(n*n!)</li><li>空间复杂度：O(n)</li></ul><h3 id=047-全排列>047 全排列Ⅱ</h3><p>在 046 全排列 的基础上，nums可包含重复数字</p><h4 id=代码-23>代码</h4><pre tabindex=0><code>class Solution {
    // 结果集
    Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
        backTrack(nums, new LinkedList&lt;&gt;(), new boolean[nums.length]);
        return new ArrayList&lt;&gt;(res);
    }

    private void backTrack(int[] nums, LinkedList&lt;Integer&gt; path, boolean[] used) {
        // 减枝
        if (path.size() == nums.length) {
            res.add(new ArrayList&lt;&gt;(path));
            return;
        }
        for (int i = 0; i &lt; nums.length; i++) {
            // 筛选
            if (used[i]) {
                continue;
            }
            path.addLast(nums[i]);
            used[i] = true;
            backTrack(nums, path, used);
            path.removeLast();
            used[i] = false;
        }
    }
}</code></pre><h4 id=复杂度-24>复杂度</h4><ul><li>时间复杂度：O(n*n!)</li><li>空间复杂度：O(n)</li></ul><h2 id=动态规划>动态规划</h2><h3 id=322零钱兑换java>[322]零钱兑换.java</h3><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。</p><h4 id=思路-18>思路</h4><ol><li>自底向上考虑，要凑到 i 元钱有 dp[i] 种情况，新建 dp 数组；</li><li>初始值：dp[0] = 0;</li><li>状态转移方程：dp[i] = min(dp[i], 1 + dp[i - coin]);</li><li>返回值：dp[amount];</li><li>剪枝：硬币金额大于目标金额。</li></ol><h4 id=代码-24>代码</h4><pre tabindex=0><code>class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 0; i &lt;= amount; i++) {
            // 要凑到 i 元钱有 dp[i] 种情况
            for (int coin : coins) {
                if (coin &gt; i) {
                    continue;
                }
                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }
}</code></pre><h4 id=复杂度-25>复杂度</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)</li></ul><h3 id=53最大子序和java>[53]最大子序和.java</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><h4 id=思路-19>思路</h4><p>因为，某一位的最大子序和无非两种情况</p><ol><li>继续累加前一个数的最大子序和</li><li>从当前数字重新累加</li></ol><p>所以，得到状态转移方程：
f(i)=max({f(i−1)+nums[i],nums[i]})</p><h4 id=代码-25>代码</h4><pre tabindex=0><code>class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}

class Solution {
    public int maxSubArray(int[] nums) {
        int left = 0, right = 0, sum = 0, res = Integer.MIN_VALUE;
        while (right &lt; nums.length) {
            sum += nums[right++];
            while (sum &lt; 0) {
                // d 是将移出窗口的字符
                sum -= nums[left++];
            }
            res = Math.max(sum, res);
        }
        int negative = Integer.MIN_VALUE;
        for (int num : nums) {
            negative = Math.max(num, negative);
        }
        return negative &lt; 0 ? negative : res;
    }
}</code></pre><h4 id=复杂度-26>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><h3 id=300最长递增子序列java>[300]最长递增子序列.java</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><h4 id=思路-20>思路</h4><p>因为，某一位的最大子序长度无非两种情况</p><ol><li>先在前面找出比当前数字更小的数字，找一个长度最长的自增 1 作为当前的最大自序长度</li><li>从当前数字重新累加（可以让初始化长度为1）</li></ol><h4 id=代码-26>代码</h4><pre tabindex=0><code>class Solution {
    public int lengthOfLIS(int[] nums) {
        final int n = nums.length;
        int[] dp = new int[n];
        // base case：dp 数组全都初始化为 1
        Arrays.fill(dp, 1);
        int res = 0;
        for (int i = 0; i &lt; n; i++) {
            // 在前面找比当前数字更小的数字，以满足递增子序列的要求。
            int cur = nums[i];
            for (int j = 0; j &lt; i; j++) {
                if (nums[j] &lt; cur)
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            // 更新最大值作为返回结果
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}</code></pre><h4 id=复杂度-27>复杂度</h4><ul><li>时间复杂度：O(n^2)</li><li>空间复杂度：O(n)</li></ul><h2 id=栈和队列>栈和队列</h2><h3 id=225用队列实现栈java>[225]用队列实现栈.java</h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><h4 id=思路-21>思路</h4><ol><li>用一个全局变量记录栈顶。</li><li>入栈、判空不做处理</li><li>额外处理出栈的 pop 操作，把队列中前 n-1 个元素出队再入队，返回末尾元素。</li></ol><h4 id=代码-27>代码</h4><pre tabindex=0><code>class MyStack {

    Queue&lt;Integer&gt; queue;
    int top;

    /**
     * Initialize your data structure here.
     */
    public MyStack() {
        queue = new LinkedList&lt;&gt;();
        top = 0;
    }

    /**
     * Push element x onto stack.
     */
    public void push(int x) {
        queue.offer(x);
        top = x;
    }

    /**
     * Removes the element on top of the stack and returns that element.
     */
    public int pop() {
        int size = queue.size();
        for (int i = 0; i &lt; size - 1; i++) {
            top = queue.peek();
            queue.offer(queue.poll());
        }
        return queue.poll();
    }

    /**
     * Get the top element.
     */
    public int top() {
        return top;
    }

    /**
     * Returns whether the stack is empty.
     */
    public boolean empty() {
        return queue.isEmpty();
    }
}</code></pre><h3 id=232用栈实现队列java>[232]用栈实现队列.java</h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）</p><h4 id=思路-22>思路</h4><ol><li>建立 2 个栈，元素先入 s1，再入 s2，这样 s2 的栈顶就相当于队尾了。</li><li>把关键操作放在 peek 处，在 pop 之前，先调用 peek ，就能确保不会出错了。</li></ol><h4 id=代码-28>代码</h4><pre tabindex=0><code>class MyQueue {

    private Stack&lt;Integer&gt; s1, s2;

    /**
     * Initialize your data structure here.
     */
    public MyQueue() {
        s1 = new Stack&lt;&gt;();
        s2 = new Stack&lt;&gt;();
    }

    /**
     * Push element x to the back of queue.
     */
    public void push(int x) {
        s1.push(x);
    }

    /**
     * Removes the element from in front of queue and returns that element.
     */
    public int pop() {
        // 将 s1 元素转移至 s2
        peek();
        return s2.pop();
    }

    /**
     * Get the front element.
     */
    public int peek() {
        if (s2.isEmpty()) {
            while (!s1.isEmpty()) {
                s2.push(s1.pop());
            }
        }
        return s2.peek();
    }

    /**
     * Returns whether the queue is empty.
     */
    public boolean empty() {
        return s1.isEmpty() &amp;&amp; s2.isEmpty();
    }
}</code></pre><h3 id=496下一个更大元素-ijava>[496]下一个更大元素 I.java</h3><p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。
请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><h4 id=思路-23>思路</h4><ol><li>从后往前遍历 nums2，用栈记录右侧大于当前数字的值；</li><li>以当前数字为 key，下一个更大元素为 value，建立一个 HashMap 存储；</li><li>遍历 nums1 ,获取每一个 key 的 value。</li></ol><h4 id=代码-29>代码</h4><pre tabindex=0><code>class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        // 从后往前遍历
        for (int i = nums2.length - 1; i &gt;= 0; i--) {
            while (!stack.isEmpty() &amp;&amp; nums2[i] &gt;= stack.peek()) {
                // 栈顶元素即将被 nums2[i] 挡住
                stack.pop();
            }
            int nextGreaterNum = stack.isEmpty() ? -1 : stack.peek();
            map.put(nums2[i], nextGreaterNum);
            stack.push(nums2[i]);
        }
        int[] res = new int[nums1.length];
        for (int i = 0; i &lt; nums1.length; i++) {
            res[i] = map.get(nums1[i]);
        }
        return res;
    }
}</code></pre><h4 id=复杂度-28>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=503下一个更大元素-iijava>[503]下一个更大元素 II.java</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><h4 id=思路-24>思路</h4><ol><li>从后往前遍历 nums，用栈记录右侧大于当前数字的值</li><li>因为数组是循环数组，所以在赋值 -1 时还要去坐标左边找找，如果还找不到更大元素，那么就返回 -1，否则就返回第一个更大元素。</li></ol><h4 id=代码-30>代码</h4><pre tabindex=0><code>class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        // 从后往前遍历
        for (int i = nums.length - 1; i &gt;= 0; i--) {
            while (!stack.isEmpty() &amp;&amp; nums[i] &gt;= stack.peek()) {
                // 栈顶元素即将被 nums[i] 挡住
                stack.pop();
            }
            if (stack.isEmpty()) {
                res[i] = -1;
                // 后面找不到了，去前面找找看
                for (int j = 0; j &lt; i; j++) {
                    if (nums[j] &gt; nums[i]) {
                        res[i] = nums[j];
                        break;
                    }
                }
            } else {
                res[i] = stack.peek();
            }
            stack.push(nums[i]);
        }
        return res;
    }
}

class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] res = new int[n];
        Arrays.fill(res, -1);
        // 单调栈中存放下标
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        for (int i = 0; i &lt; n * 2; i++) {
            while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i % n]) {
                // 出栈的值的下一个更大元素即为 nums[i]
                res[stack.pop()] = nums[i % n];
            }
            if (i &lt; n) {
                stack.push(i);
            }
        }
        return res;
    }
}</code></pre><h4 id=复杂度-29>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=1047删除字符串中的所有相邻重复项java>[1047]删除字符串中的所有相邻重复项.java</h3><p>//给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 //// 在 S 上反复执行重复项删除操作，直到无法继续删除。 //// 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 //// //// 示例： //// 输入：&ldquo;abbaca&rdquo;//输出：&ldquo;ca&rdquo;//解释：//例如，在 &ldquo;abbaca&rdquo; 中，我们可以删除 &ldquo;bb&rdquo; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &ldquo;aaca&rdquo;，其中又//只有 &ldquo;aa&rdquo; 可以执行重复项删除操作，所以最后的字符串为 &ldquo;ca&rdquo;。</p><pre tabindex=0><code>class Solution {
    public String removeDuplicates(String s) {
        char[] stack = new char[s.length()];
        int index = 0;
        for (char currentChar : s.toCharArray()) {
            if (index &gt; 0 &amp;&amp; stack[index - 1] == currentChar) {
                index--;
            } else {
                stack[index++] = currentChar;
            }
        }
        return new String(stack, 0, index);
    }
}</code></pre><h2 id=其他>其他</h2><h3 id=并查集union-find算法990等式方程的可满足性java>并查集（Union-Find）算法：[990]等式方程的可满足性.java</h3><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：&ldquo;a==b&rdquo; 或 &ldquo;a!=b&rdquo;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p><h4 id=思路-25>思路</h4><ol><li>将方程分成等式和不等式两类；</li><li>初始化「图」；</li><li>根据等式连接两两节点；</li><li>判断不等式是否成立。</li></ol><h4 id=代码-31>代码</h4><pre tabindex=0><code>class Solution {
    // 节点 x 的节点是 parent[x]
    private int[] parent;
    // 新增一个数组记录树的“重量”
    private int[] size;

    public boolean equationsPossible(String[] equations) {
        // 1. 将方程分成等式和不等式两类
        List&lt;String&gt; equals = new LinkedList&lt;&gt;();
        List&lt;String&gt; unEquals = new LinkedList&lt;&gt;();
        for (String equation : equations) {
            char c = equation.charAt(1);
            if (c == &#39;=&#39;) {
                equals.add(equation);
            } else if (c == &#39;!&#39;) {
                unEquals.add(equation);
            }
        }
        // 2. 初始化「图」
        parent = new int[26];
        size = new int[26];
        for (int i = 0; i &lt; 26; i++) {
            // 父节点指针初始指向自己
            parent[i] = i;
            // 重量应该初始化 1
            size[i] = 1;
        }
        // 3. 根据等式连接两两节点
        for (String equal : equals) {
            int a = equal.charAt(0) - &#39;a&#39;;
            int b = equal.charAt(3) - &#39;a&#39;;
            union(a, b);
        }
        // 4. 判断不等式是否成立
        for (String unEqual : unEquals) {
            int a = unEqual.charAt(0) - &#39;a&#39;;
            int b = unEqual.charAt(3) - &#39;a&#39;;
            int rootA = find(a);
            int rootB = find(b);
            if (rootA == rootB) {
                return false;
            }
        }
        return true;
    }

    /* 将 p 和 q 连接 */
    private void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            // 二者已连接
            return;
        }
        // 将两棵树合并为一棵，小树接到大树下面
        if (size[rootP] &gt; size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
    }

    /* 返回某个节点 x 的根节点 */
    private int find(int x) {
        // 根节点的 parent[x] == x
        while (parent[x] != x) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
}</code></pre><h4 id=复杂度-30>复杂度</h4><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><h3 id=146lru-缓存机制java>[146]LRU 缓存机制.java</h3><p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><h4 id=思路-26>思路</h4><ol><li>需要一个有时序的 Map 来实现算法，在 Java 语言中可以使用 <strong>LinkedHashMap</strong>；</li><li>LRU 的核心是 makeRecently 方法，它把一对 key-value 放到最新的位置，也就是链表的队尾。</li><li>get 方法直接去 Map 中找，并调用 makeRecently 方法；</li><li>put 方法需要考虑缓存大小超出给定容量的情况，若 key 是第一次出现，则需要删除<strong>最久未使用</strong>的 key-value 对，并添加新的 key-value 对；若原本就存在 key，则更新它的 value，并调用 makeRecently 方法。</li></ol><h4 id=代码-32>代码</h4><pre tabindex=0><code>class LRUCache {
    int capacity;
    LinkedHashMap&lt;Integer, Integer&gt; cache;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        cache = new LinkedHashMap&lt;&gt;();
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        return makeRecently(key);
    }

    public void put(int key, int value) {
        // 容量已满，需要移除
        if (cache.size() == capacity &amp;&amp; !cache.containsKey(key)) {
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        cache.put(key, value);
        makeRecently(key);
    }

    private int makeRecently(int key) {
        int val = cache.get(key);
        // 删除 key，重新插入到队尾
        cache.remove(key);
        cache.put(key, val);
        return val;
    }
}</code></pre><h4 id=复杂度-31>复杂度</h4><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(capacity)</li></ul><h3 id=050-powxn>050 Pow(x,n)</h3><h4 id=int转换为long>int转换为long</h4><p>Java 代码中 int32 变量 n \in [-2147483648, 2147483647]，因此当 n = -2147483648 时执行 n = -n会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可。</p><h4 id=代码迭代>代码（迭代）</h4><pre tabindex=0><code>class Solution {
    public double myPow(double x, int n) {
        if (x == 0.0f) return 0.0d;
        //防止n=-n赋值越界
        long b = n;
        // n=0情况返回1
        double res = 1.0;
        if (b &lt; 0) {
            x = 1 / x;
            b = -b;
        }
        while (b &gt; 0) {
            if ((b &amp; 1) == 1) {
                //奇数
                res *= x;
            }
            x *= x;
            //按位右移，相当于除以2
            b &gt;&gt;= 1;
        }
        return res;
    }
}</code></pre><h4 id=复杂度-32>复杂度</h4><ul><li>时间复杂度：O(logn)</li><li>空间复杂度：O(1)</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="Updated on 2023-08-08 15:51:32">Updated on 2023-08-08&nbsp;</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://leni.fun/posts/leetcode/ data-title="LeetCode 大全"><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/leetcode/ class=post-tag>LeetCode</a><a href=/tags/ds/ class=post-tag>DS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/kaggle/ class=post-nav-item rel=prev title=Kaggle><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Kaggle</a>
<a href=/posts/lfu/ class=post-nav-item rel=next title=LFU>LFU<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2023</span><span class=author itemprop=copyrightHolder>
<a href=/>都将会</a></span><span class="license footer-divider">Back-End Engineer</span></div><div class="footer-line statistics"><span class=site-time title='Website running ...'><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="run-times ms-1">Website running ...</span></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title='Total visitors'><i class="fa-regular fa-user fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title='Total visits'><i class="fa-regular fa-eye fa-fw" aria-hidden=true></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/hihihiman/blog title=博客源码 target=_blank rel="external nofollow" class="github-corner left d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;bottom:0;--bg-progress:#000;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>Theme FixIt works best with JavaScript enabled.</div></noscript></div><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><link rel=stylesheet href=/lib/pace/themes/pink/pace-theme-center-atom.css><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/fuse/fuse.min.js defer></script><script src=/lib/instant-page/instantpage.min.js async defer type=module></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/typeit/index.umd.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script src=/lib/pace/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"Copy to clipboard",editLockTitle:"Lock editable code block",editUnLockTitle:"Unlock editable code block",editable:!0,maxShownLines:64},comment:{enable:!1},cookieconsent:{content:{dismiss:"Got it!",link:"Learn more",message:"This website uses Cookies to improve your experience."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},data:{"typeit-header-subtitle-desktop":"的博客","typeit-header-subtitle-mobile":"的博客"},enablePWA:!0,pangu:{enable:!0,selector:"article"},search:{distance:100,findAllMatches:!1,highlightTag:"em",ignoreFieldNorm:!0,ignoreLocation:!0,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"No results found",snippetLength:50,threshold:.3,useExtendedSearch:!0},siteTime:"2023-08-06T23:31:00+08:00",typeit:{cursorChar:"_",cursorSpeed:1e3,data:{"typeit-header-subtitle-desktop":["typeit-header-subtitle-desktop"],"typeit-header-subtitle-mobile":["typeit-header-subtitle-mobile"]},duration:-1,loop:!0,speed:100}}</script><script src=/js/theme.min.js defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js></script><script type=text/javascript src=/js/custom.js></script></body></html>